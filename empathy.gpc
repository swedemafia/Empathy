/***
*
*
*	Author:		SwedeMafia
*	Script:		Empathy
*	Version:	2.00
*
*
****************************************************************/
define DEBUG = FALSE; // Developer default settings

/**************************************************************/
//	Variables
/**************************************************************/
//
// (Anti-drift) variables
int antiDriftStickValue, antiDriftNewValue;
int antiDriftLowValue, antiDriftHighValue;
int antiDriftCompensateValue;
int antiDriftCalibrationLow, antiDriftCalibrationHigh;
int antiDriftCalibrationValue, antiDriftCalibrationRangeValue;
int antiDriftCalibrationState, antiDriftCalibrationInRange, antiDriftCalibrationCanSet;
int antiDriftCalibrationPolarStick, antiDriftCalibrationStick, antiDriftCalibrationDirection;
// (Anti-recoil) variables
int antiRecoilQuickEdit;
// (Controller) Buttons
int button[12];
// (Controller) Sticks
int aimX, aimY;
int moveY, moveX;
// (Controller) Current ADS & Fire button values
int holdingADS, holdingFire;
// Display buffer
int displayBuffer, displayBufferInsertCopyValue, displayBufferInsertNumberOfDigits;
int displayBufferInsertDigits[5];
// Home screen display variables
int homeHide, homeUpdate;
// Loop iterators
int i, j;
// Memory and storage variables
int spvar_current_bit, spvar_current_slot, spvar_current_value, spvar_tmp, spvar_bits;
// (Menu) Edit menu variables
int editMenu, editMenuIndex, editMenuUpdate;
int editMenuSelectedColumn, editMenuSelectedPage, editMenuSelectedRow;
// (Menu) Mod menu variables
int modMenu, modMenuIndex, modMenuMin, modMenuMax, modMenuUpdate;
// (Profiles)
int currentProfile, menuProfile;
// (Profiles) Current profile weapon
int currentWeapon[2];
// Rapid fire
int rapidFire[2];
// (Screen saver)
int screenSaverEnabled, screenSaverCounter, screenSaverWeaponCounter;
// (Screen saver) Script uptime
int uptimeCounter, uptimeDays, uptimeHours, uptimeMinutes, uptimeSeconds;
// Script paused
int scriptPaused;


/**************************************************************/
//	User-defined configuration variables
/**************************************************************/
// Anti-drift
int varAntidrift;
int varAntidriftLeft[4], varAntidriftRight[4];
// Anti-recoil
int varAntiRecoilStart[32], varAntiRecoilMid[21], varAntiRecoilEnd[32];
int varAntiRecoilStartTime[32], varAntiRecoilMidTime[32];
int varAntiRecoilStart_H[32], varAntiRecoilMid_H[32], varAntiRecoilEnd_H[32];
int varAntiRecoilStartTime_H[32], varAntiRecoilMidTime_H[32];
// Controller
int varControllerButtonLayout;
// Rapid fire
int varRapidFireRecoil[32], varRapidFireSpeed;
// Profiles
int varProfileColor[2];
// Settings
int varAutoFocus;
int varBlockRumble;
int varDeadzone[2];
int varInverted;
// Toggles
int varToggleButton[4];


/**************************************************************/
//	Enumerations
/**************************************************************/
// (Anti-drift) Calibration direction
enum { antiDriftUp, antiDriftDown, antiDriftLeft, antiDriftRight }
// (Anti-drift) Calibratoin stick
enum { antiDriftLeftStick, antiDriftRightStick }
// (Controller) Button layout IDs
enum { cblTypeA, cblTypeB, cblTypeC }
// (Controller) Button IDs
enum { aim, ads, melee, fire, weapon, interact, action, jump, leanL, leanR, focus, zoom }
// (Display) Color IDs
enum { red, orange, gold, white, yellow, green, teal, blue, purple, pink }
// (Display) Formatting
enum { displayString, displayNumber }
// (Display) Home screen message IDs
enum { homeScriptName, homeScriptVersion, homeScriptAuthor }
// (Display) HSB map lookup IDs
enum { hue, saturation, brightness }
// (Display) Text alignment and formatting IDs
enum {
	alignCenter = -2, alignRight, alignLeft = 5,
	alignBottom = -1, alignTop = 5
}
// (Menu) Cycle value IDs
enum { cycleValueUp, cycleValueDown }
// (Menu) Edit menu IDs
enum {
	editMenuAntidrift, editMenuAntidriftCalibration, editMenuAntidriftTest, editMenuAntidriftValues, // Anti-drift
	editMenuAntiRecoil, // Anti-recoil
	editMenuControllerButtonLayout, // Controller
	editMenuProfileSwitch, editMenuProfileColors, // Profiles
	editMenuAutoFocus, editMenuBlockRumble, editMenuDeadzone, editMenuInverted, // Settings
	editMenuToggleRapidFire // Toggles
}
// (Menu) Edit menu navigation
enum {
	editMenuMin, editMenuMax, editMenuShowProfile,
	editMenuLeft, editMenuRight,
	editMenuUp, editMenuDown,
	editMenuEnter, editMenuExit, editMenuNextPage, editMenuPreviousPage, editMenuAction
}
// (Menu) Mod menu IDs
enum {
	modMenuAntidrift, modMenuAntiRecoil, modMenuController,
	modMenuProfiles, modMenuSettings, modMenuToggles
}
// (Menu) Mod menu navigation and actions
enum {
	modMenuPrevious, modMenuCurrent, modMenuNext,
	modMenuDown, modMenuUp,
	modMenuExit, modMenuEnter
}
// (Menu) Mod menu items
const int8 modMenuItems[][] = {
	// Previous			Current			Next
	{ modMenuToggles, modMenuAntidrift, modMenuAntiRecoil },
	{ modMenuAntidrift, modMenuAntiRecoil, modMenuController },
	{ modMenuAntiRecoil, modMenuController, modMenuProfiles },
	{ modMenuController, modMenuProfiles, modMenuSettings },
	{ modMenuProfiles, modMenuSettings, modMenuToggles },
	{ modMenuSettings, modMenuToggles, modMenuAntidrift }
}
// (Settings) Deadzone IDs
enum { deadzoneLeft, deadzoneRight }
// (Toggles) Array IDs
enum { toggleProfile = 0, toggleRapidFire = 2 }
/**************************************************************/
//	Constants (strings)
/**************************************************************/
// (Anti-drift) Calibration direction
const string antiDriftCalibrationDirectionPrompt[] = { "Direction: Up", "Direction: Down", "Direction: Left", "Direction: Right" }
// (Anti-drift) Calibration result
const string antiDriftCalibrationResult[] = { "Failed", "Success", "Cancelled", "Reset Value" }
// (Anti-drift) Calibration state
const string antiDriftCalibrationStateMsg[] = { "Press A/Cross", "Waiting" }
// (Anti-drift) Calibration stick
const string antiDriftCalibrationStickPrompt[] = { "Joystick: Left", "Joystick: Right" }
// (Anti-drift) Values display
const string antiDriftValues[] = { "U: ", "D: ", "L: ", "R: " }
// (Anti-recoil) Recoil stage messages
const string recoilMenu[] = { "V-Beg: ", "V-Mid: ", "V-End: ", "H-Beg: ", "H-Mid: ", "H-End: ", "V-Recoil: ", "R-Recoil: ", "R-Speed:  " }

// (Anti-recoil) Weapon names
const string weaponName[] = {
	// AR (12)
	"AKM", "Beryl M762", "G36C", "M416", "M16A4", "SCAR-L", "Mk47 Mutant", "QBZ", "AUG", "Groza", "ACE32", "K2",
	// SMG (8)
	"PP-19 Bizon", "Tommy Gun", "UMP45", "Micro UZI", "Vector", "MP5K", "P90", "MP9",
	// LMG (3)
	"DP-28", "M249", "MG3",
	// DMR (7)
	"SLR", "Mini14", "SKS", "VSS", "QBU", "Mk14", "Mk12",
	// SR (1)
	"Sniper",
	// Shotgun (1)
	"Shotgun"
}
// (Controller) Button layout descriptions
const string buttonLayoutName[] = {
	"Type A", "Type B", "Type C"
}
// (Controller) Button names [PlayStation]
const string controllerButtonsPS4[] = {
	"not set", "", "",
	"R1", "R2", "", "L1", "L2",
	"", "", "", "", "",
	"Up", "Down", "Left", "Right",
	"Triangle", "Circle", "Cross", "Square"
}
// (Controller) Button names [XBOX]
const string controllerButtonsXBOX[] = {
	"not set", "", "",
	"RB", "RT", "", "LB", "LT",
	"", "", "", "", "",
	"Up", "Down", "Left", "Right",
	"Y", "B", "A", "X"
}
// (Display) Color names
const string colorName[] = {
	"Red", "Orange", "Gold", "White", "Yellow", "Green", "Teal", "Blue", "Purple", "Pink"
}
// (Display) Home screen messages
const string homeScreenMessages[] = { "Empathy", "Version 2.00", "Swedemafia" }
// (Menu) Edit menu names
const string editMenuNames[] = {
	"Anti-drift", "Calibration", "Drift Test", "Drift Values", // Antidrift
	"Anti-recoil", // Antirecoil
	"Button Layout", // Controller
	"Profile Buttons", "Profile Colors", // Profiles
	"Auto Focus", "Block Rumble", "Deadzone", "Inverted", // Settings
	"Rapid Fire" // Toggles
}
// (Menu) Mod menu names
const string modMenuNames[] = {
	"Anti-drift", "Anti-recoil", "Controller",
	"Profiles", "Settings", "Toggles"
}
// (Options) Rapid Fire Speed
const string rapidFireSpeed = "Shots/Second: "
// (Profile) Profile names
const string profileName[] = { "Primary", "Secondary" }
// (Profiles) Profile toggle/color prompts
const string profileToggleMsg[] = {
	"Resync: ", "Switch: ", // Profile Switch
	"Button 1: ", "Button 2: ", // Toggle Buttons
	"Primary:   ", "Secondary: " // Profile Colors
}
// Script paused notification
const string scriptPausedMsg = "Script Paused";
// (Settings) Saved notification
const string settingsSaved = "Settings Saved";
// (Settings) Deadzone prompt
const string stickName[] = { "Left: ", "Right: " }
// (Toggles) On/off messages
const string toggleOffOn[] = { "Off", "On" }

// (Toggles) Toggle combo messages
const string toggleMessages[] = { "Rapid Fire: Off", "Rapid Fire: On" }

/**************************************************************/
//	Constants (integers)
/**************************************************************/
// (Anti-recoil) Weapon keyboard key map
const int8 weaponKey[] = {
	KEY_Q, KEY_W, KEY_E, KEY_R, KEY_T, KEY_Y, KEY_U, KEY_I, KEY_O, KEY_P, KEY_LEFTBRACE, KEY_RIGHTBRACE,
	KEY_A, KEY_S, KEY_D, KEY_F, KEY_G, KEY_H, KEY_J, KEY_K, KEY_L, KEY_SEMICOLON, KEY_APOSTROPHE,
	KEY_Z, KEY_X, KEY_C, KEY_V, KEY_B, KEY_N, KEY_M, KEY_COMMA, KEY_DOT
}

// (Anti-recoil) Weapon IDs
enum {
	akm, beryl, g36c, m416, m16a4, scar, mutant, qbz, aug, groza, ace32, k2,
	bizon, tommy, ump, uzi, vector, mp5, p90, mp9,
	dp28, m249, mg3,
	slr, mini14, sks, vss, qbu, mk14, mk12,
	sniper, shotgun
}

// (Controller) List of possible buttons to be used for a toggle combination
const int8 controllerButtons[] = {
	XB1_VIEW,
	XB1_RB, XB1_RT, XB1_LB, XB1_LT,
	XB1_UP, XB1_DOWN, XB1_LEFT, XB1_RIGHT,
	XB1_Y, XB1_B, XB1_A, XB1_X
}

// (Controller) Button Layout map
const int8 buttonLayoutMap[][] = {
	// Aim	  ADS	  Melee   Fire    Switch Interact Action Jump   LeanL   LeanR   Focus   Zoom
	{ XB1_LT, XB1_LT, XB1_UP, XB1_RT, XB1_Y, XB1_X,   XB1_B, XB1_A, XB1_LS, XB1_RS, XB1_LB, XB1_RB }, // Type A
	{ XB1_LB, XB1_LT, XB1_UP, XB1_RT, XB1_Y, XB1_X,   XB1_B, XB1_A, XB1_LS, XB1_RS, XB1_LB, XB1_RB }, // Type B
	{ XB1_LT, XB1_LT, XB1_RIGHT, XB1_RT, XB1_Y, XB1_X, XB1_B, XB1_A, XB1_LB, XB1_RB, XB1_LS, XB1_RS} // Type C
}
// (Display) HSB color values
const int16 colorValues[][] = {
	{ 0, 100, 75 }, // Red
	{ 10, 100, 75 }, // Orange
	{ 17, 100, 100 }, // Gold
	{ 20, 50, 100 }, // White
	{ 30, 100, 100 }, // Yellow
	{ 120, 100, 75 }, // Green
	{ 135, 100, 75 }, // Teal
	{ 200, 100, 50 }, // Blue
	{ 300, 100, 50 }, // Purple
	{ 359, 50, 75 } // Pink
}
// (Display) Line numbers for OLED_FONT_SMALL
const int8 lineNumber[] = { 22, 34, 46 }
// (Display) Font height
const int8 fontHeight[] = { OLED_FONT_SMALL_HEIGHT, OLED_FONT_MEDIUM_HEIGHT, OLED_FONT_LARGE_HEIGHT }
// (Display) Font width
const int8 fontWidth[] = { OLED_FONT_SMALL_WIDTH, OLED_FONT_MEDIUM_WIDTH, OLED_FONT_LARGE_WIDTH }
// (Menu) Edit menu items
const int8 editMenuItems[][] = {
	// Minimum			Maximum				Show Profile
	{ editMenuAntidrift, editMenuAntidriftValues, FALSE }, // Anti-drift
	{ editMenuAntiRecoil, editMenuAntiRecoil, FALSE }, // Anti-recoil
	{ editMenuControllerButtonLayout, editMenuControllerButtonLayout, FALSE }, // Controller
	{ editMenuProfileSwitch, editMenuProfileColors, FALSE }, // Profiles
	{ editMenuAutoFocus, editMenuInverted, FALSE }, // Settings
	{ editMenuToggleRapidFire, editMenuToggleRapidFire, FALSE } // Toggles
}


/**************************************************************/
//	Begin script
/**************************************************************/
init {
	// Initialize menu min/max
	modMenuMin = modMenuAntidrift;
	modMenuMax = modMenuToggles;
	
	homeUpdate = 1; // Display home screen on startup
	displayBuffer = 1; // Initialize display buffer
	
	// Set default weapons
	currentWeapon[0] = akm;
	currentWeapon[1] = slr;
	
	loadSettings(); // Load user-defined settings
}

main {
	if(!homeHide) { // If home screen is visible
		if(!rapidFire[currentProfile]) {
			setProfileLedColor(currentProfile); // Set LED color to notify user of current profile
		}
		if(homeUpdate) { // See if we need to redraw homescreen
			homeUpdate = !homeUpdate; // Disable home screen update
			displayHomeScreen(); // Show home screen
		}
	} else {
		if(!scriptPaused) { // If not in pause mode, set LED color
			if(!combo_running(cboCalibrationComplete)) { // Do not mess with LED if cboCalibrationComplete is running
				if(editMenu && (editMenuIndex == editMenuProfileColors)) {
					setProfileLedColor(editMenuSelectedRow); // Set LED to color of profile color being edited
				} else if(editMenu && antiDriftCalibrationState && !antiDriftCalibrationInRange) { // While during anti-drift calibration mode
					setLedColor(orange);
				} else if(editMenu && antiDriftCalibrationState && antiDriftCalibrationInRange) { // In target range for stick movement
					setLedColor(green); // here
				} else if (editMenu) {
					setProfileLedColor(menuProfile); // Set LED to profile being edited (in edit menu)
				} else {
					if(!checkCombos()) {
						setProfileLedColor(currentProfile); // Set LED to current profile (not in menus)
					}
				}
			}
		}
	}
	
	// Only remove if calibration is NOT running
	if(!antiDriftCalibrationState) {
		removeDriftAndApplyDeadzone(); // Remove stick drift and apply deadzone
	}
	
	// User can only access menus if script is not scriptPaused
	if(antiDriftCalibrationState) {
		if(antiDriftCalibrationStick == antiDriftLeftStick) {
			if(antiDriftCalibrationDirection == antiDriftUp || antiDriftCalibrationDirection == antiDriftDown) {
				antiDriftCalibrationPolarStick = POLAR_LY;
				checkCalibrationRange();
			} else {
				antiDriftCalibrationPolarStick = POLAR_LX;
				checkCalibrationRange();
			}
		} else {
			if(antiDriftCalibrationDirection == antiDriftUp || antiDriftCalibrationDirection == antiDriftDown) {
				antiDriftCalibrationPolarStick = POLAR_RY;
				checkCalibrationRange();
			} else {
				antiDriftCalibrationPolarStick = POLAR_RX;
				checkCalibrationRange();
			}
		}
	}
	
	// If script is not paused, user may enter menus or use toggle combinations
	if(!scriptPaused) {
		 // If screen saver is enabled, see if we have been idle long enough
		 if(!homeHide && !modMenu && !editMenu && !screenSaverEnabled && !checkCombos()) { 
			screenSaverCounter += get_rtime(); // Increase counter by value of VM speed
			// See if we have been idle long enough
			if(screenSaverCounter >= 2000) { 
				screenSaverEnabled = !screenSaverEnabled; // Enable screen saver
				screenSaverCounter = 0;
				cls_oled(OLED_BLACK); // Do this here because there is no need to reset to black every single time in displayScreenSaver()
			}
		} else if(screenSaverEnabled && !combo_running(cboWeaponDisplay)) {
		
			screenSaverWeaponCounter += get_rtime();
			
			if(screenSaverWeaponCounter >= 3500) {
				screenSaverWeaponCounter = 0;
				combo_run(cboWeaponDisplay);
			}
		}
		
		// If user is at home screen or screen saver is enabled, check for request to enter mod menu
		if(!homeHide || screenSaverEnabled && !antiDriftCalibrationState) { 
			// See if user is entering mod menu
			if(get_val(button[ads]) && event_press(XB1_MENU) && !antiRecoilQuickEdit && !checkCombos() && !combo_running(cboSwitchProfile)) { 
				homeHide = !homeHide; // Hide home screen
				modMenu = !modMenu; // Display mod menu
				modMenuUpdate = !modMenuUpdate; // Enable mod menu update
				menuProfile = currentProfile; // Set profile in menu to current profile
				screenSaverCounter = 0; // Reset screen saver timer
				// See if screen saver is currently enabled
				if(screenSaverEnabled) {
					screenSaverEnabled = !screenSaverEnabled; // Disable screen saver
					homeUpdate = !homeUpdate; // Disable home display update
				}
			} else if(get_val(button[ads]) && event_press(XB1_VIEW) && !antiRecoilQuickEdit && !checkCombos() && !combo_running(cboSwitchProfile)) {
				homeHide = !homeHide; // Hide home screen
				editMenu = !editMenu; // Enable edit menu
				modMenuIndex = modMenuAntiRecoil; // Set mod menu to anti-recoil
				editMenuIndex = editMenuAntiRecoil; // Set edit menu to anti-recoil
				antiRecoilQuickEdit = !antiRecoilQuickEdit; // Enable recoil quick edit
				menuProfile = currentProfile; // Set profile in menu to current profile
				screenSaverCounter = 0; // Reset screen saver timer
				displayEditMenu(); // Display anti-recoil edit menu
				// See if screen saver is currently enabled
				if(screenSaverEnabled) {
					screenSaverEnabled = !screenSaverEnabled; // Disable screen saver
					homeUpdate = !homeUpdate; // Disable home display update
				}
			}
		} else if (modMenu && !editMenu) { // Mod menu
			checkModMenuEvent(); // Check for mod menu event
		} else if (!modMenu && editMenu) { // Edit menu
			checkEditMenuEvent(); // Check for edit menu event
		}
		// Check if user wants to pause the script (and not in menus) then execute mods
		if(!checkPause() && !modMenu && !editMenu) {
		
			checkAssist(); // Execute any enabled assists (Aim Assist [+etc.], Rotation Assist, Anti-Recoil)
			checkOptions(); // Execute any running options
			
			if(rapidFire[currentProfile] && !checkCombos()) {
				combo_run(cboToggleAlert);
			}
		}
		
		checkToggles(); // Check for toggles
		checkKeys(); // Check for keys
		blockActionButtons(); // Block any action buttons
		blockMenuButtons(); // Block any buttons pressed while in menu
	} else {
		checkUnpause();
	}
	
	checkBlockRumble(); // Always check for block rumble whether in menus or not
}

// Block output to controller from menu actions
function blockActionButtons() {
	
	// Loop through each toggle combination and block if being used
	for(i = 0; i < sizeof(varToggleButton) / sizeof(varToggleButton[0]); i += 2) {
		if(varToggleButton[i] && varToggleButton[i + 1]) {
			if(get_ival(varToggleButton[i])) {
				set_val(varToggleButton[i + 1], 0);
			}
		}
	}
	
	// Block quick edit recoil and entering the menu buttons
	if(get_val(button[ads])) {
		set_val(XB1_MENU, 0);
		set_val(XB1_VIEW, 0);
	}
}

// Block output to controller from menu actions
function blockMenuButtons() {

	// Block all buttons while in a menu
	if(modMenu || editMenu || antiRecoilQuickEdit) {
		block_all_inputs();
	}
}

// Prepares the display buffer for a multiple item menu
function buildSelectedItemBuffer(type, message, value) {
	// Build display
	insertString(message);
	
	// Determine data type being used
	if(type == displayString) {
		insertString(value);
	} else {
		insertNumber(value);
	}
}

// Checks the stick when in calibration mode to make sure the
// user has moved the stick to the appropriate range prior to
// releasing the stick and setting the new value
function checkCalibrationRange() {
	// Determine target range
	if((antiDriftCalibrationDirection == antiDriftLeft) || (antiDriftCalibrationDirection == antiDriftUp)) {
		antiDriftCalibrationLow = -11468; // 35
		antiDriftCalibrationHigh = -8191 // 25
	} else {
		antiDriftCalibrationLow = 8191; // 25
		antiDriftCalibrationHigh = 11468; // 35
	}
	
	// Get stick value
	antiDriftCalibrationRangeValue = get_val(antiDriftCalibrationPolarStick);
	
	// See if stick is moved within boundaries
	if((antiDriftCalibrationRangeValue >= antiDriftCalibrationLow) && (antiDriftCalibrationRangeValue <= antiDriftCalibrationHigh)) {
		// Notify user it is in range and allow calibration to proceed
		antiDriftCalibrationInRange = TRUE;
		antiDriftCalibrationCanSet = TRUE;
	} else if(((antiDriftCalibrationDirection == antiDriftLeft) || (antiDriftCalibrationDirection == antiDriftUp)) && antiDriftCalibrationRangeValue < antiDriftCalibrationLow) {
		// Stick moved too far, reading will be inaccurate.  Stick pulls to hard back to center
		antiDriftCalibrationCanSet = FALSE;
		antiDriftCalibrationInRange = FALSE;
	} else if(((antiDriftCalibrationDirection == antiDriftRight) || (antiDriftCalibrationDirection == antiDriftDown)) && antiDriftCalibrationRangeValue > antiDriftCalibrationHigh) {
		// Stick moved too far, reading will be inaccurate.  Stick pulls to hard back to center
		antiDriftCalibrationCanSet = FALSE;
		antiDriftCalibrationInRange = FALSE;
	} else {
		// Release zone not met
		antiDriftCalibrationInRange = FALSE;
	} 
}

// Checks if a status change combo is running (i.e. action failed/success)
function checkCombos() {
	if(combo_running(cboActionFailed)) {
		return 1;
	} else if(combo_running(cboActionSuccess)) {
		return 1;
	} else if(combo_running(cboSaveSettings)) {
		return 1;
	} else if(combo_running(cboToggleOn) || combo_running(cboToggleOff)) {
		return 1;
	}
	return 0;
}

// Checks for key presses on the keyboard
function checkKeys() {
	// Loop through each possible weapon
	for(i = 0; i < sizeof(weaponKey); i++) {
		// Check if user is pressing a key that corresponds to a weapon
		if(get_keyboard(weaponKey[i])) {
			// Change current weapon on current profile
			currentWeapon[currentProfile] = i;
			// Check if user is currently editing recoil
			if(editMenuIndex == editMenuAntiRecoil) {
				editMenuUpdate = !editMenuUpdate; // Update edit display
				editMenuSelectedColumn = 0;
				editMenuSelectedRow = 0;
				editMenuSelectedPage = 0;
			} else {
				switchProfile(currentProfile);
			}
			return;
		}
	}
}

// Checks for toggle combination buttons to be pressed
function checkToggles() {
	// Only allow toggle combinations to be pressed if user is not in a menu
	if(!modMenu && !editMenu) {
		// Loop through all toggle combinations
		for(i = 0; i < sizeof(varToggleButton) / sizeof(varToggleButton[0]); i += 2) {
			// Only process if a toggle is set
			if(varToggleButton[i] && varToggleButton[i + 1]) {
				// See if toggle is requested
				if(get_val(varToggleButton[i]) && event_release(varToggleButton[i + 1])) {
					dispatchToggle(i);
					return;
				}
			}
		}
		// Switch profile
		if(varToggleButton[toggleProfile + 1] && event_release(varToggleButton[toggleProfile + 1])) {
			switchProfile(!currentProfile);
			return;
		}
	}
	// Profile switch (in-menu)
	if(((editMenu && editMenuItems[modMenuIndex][editMenuShowProfile]) || (editMenuIndex == editMenuAntiRecoil)) && event_release(XB1_Y)) {
		menuProfile = !menuProfile; // Switch to next profile
		editMenuSelectedColumn = 0;
		editMenuSelectedPage = 0;
		editMenuSelectedRow = 0;
		editMenuUpdate = 2; // Enable edit menu update (no alert)
	}
}

// Determine which Assist mods must be executed
// - Aim Assist (+etc.), Rotation Assist, Anti-recoil
function checkAssist() {
	// Check Anti-recoil
	if(varControllerButtonLayout == cblTypeA) {
		if(get_val(button[fire])) {
			executeAntiRecoil();
		} else if(!get_val(button[fire])) {
			antiRecoilStateX = 0;
			antiRecoilStateY = 0;
			antiRecoilKickDurationX = 0; // Reset counter
			antiRecoilKickDurationY = 0; // Reset counter
		}
		
	} else if(varControllerButtonLayout >= cblTypeB) {
		if(get_val(button[ads]) && get_val(button[fire])) {
			executeAntiRecoil();
		} else if (!get_val(button[fire])) {
			antiRecoilStateX = 0;
			antiRecoilStateY = 0;
			antiRecoilKickDurationX = 0; // Reset counter
			antiRecoilKickDurationY = 0; // Reset counter
		}
	}
}

// Checks for rumble block state
function checkBlockRumble() {
	if(varBlockRumble) {
		block_rumble();
	}
}

// Check for edit menu event
function checkEditMenuEvent() {
	// See if edit menu needs to update to the display
	if(editMenuUpdate) {
		displayEditMenu(); // Display edit menu
		editMenuUpdate = !editMenuUpdate; // Disable edit menu update
	}
	
	// See if we are setting toggle combination buttons
	switch(editMenuIndex) {
		case editMenuProfileSwitch {
			createToggle(toggleProfile);
			break;
		} case editMenuToggleRapidFire {
			createToggle(toggleRapidFire);
			break;
		}
	}
	
	// Check for events (only responsive to presses under 1000ms)
	if(checkEvent(XB1_LEFT)) { // Request edit menu cycle left
		cycleEditMenu(editMenuLeft);
	} else if(checkEvent(XB1_RIGHT)) { // Request edit menu cycle right
		cycleEditMenu(editMenuRight);
	} else if(checkEvent(XB1_UP)) { // Request edit menu cycle up
		cycleEditMenu(editMenuUp);
	} else if(checkEvent(XB1_DOWN)) { // Request edit menu cycle down
		cycleEditMenu(editMenuDown);
	} else if(checkEvent(XB1_A)) {
		cycleEditMenu(editMenuEnter);
	} else if(checkEvent(XB1_B)) { // Exit edit menu to mod menu
		cycleEditMenu(editMenuExit);
	} else if(checkEvent(XB1_VIEW)) {
		cycleEditMenu(editMenuAction);
	} else if(checkEvent(XB1_RB)) { // Next page
		cycleEditMenu(editMenuNextPage);
	} else if(checkEvent(XB1_LB)) { // Previous page
		cycleEditMenu(editMenuPreviousPage);
	}
	
	if(editMenuIndex == editMenuAntidriftTest) {
		editMenuUpdate = !editMenuUpdate; // Constantly updating
	}
}

// Determine if an event is being called
function checkEvent(button) {
	return (event_release(button) && (get_ptime(button) < 1000));
}

// Check for mod menu event
function checkModMenuEvent() {
	// See if mod menu needs to update to the display
	if(modMenuUpdate) {
		displayModMenu(); // Display mod menu
		modMenuUpdate = !modMenuUpdate; // Disable mod menu update
	}
	
	// Check for events
	if(event_release(XB1_DOWN)) { // Request mod menu cycle downwards
		cycleModMenu(modMenuDown);
	} else if(event_release(XB1_UP)) {// Request mod menu cycle upwards
		cycleModMenu(modMenuUp); 
	} else if(event_release(XB1_A)) { // Request enter mod menu
		cycleModMenu(modMenuEnter);
	} else if(event_release(XB1_B)) { // Exit mod menu to home screen
		cycleModMenu(modMenuExit);
	}
}

// Checks for running options and executes them if enabled
function checkOptions() {
	// Auto Focus
	if(varAutoFocus[currentProfile] && (varControllerButtonLayout >= cblTypeB)) {
		// If aiming, execute combo
		if(get_val(button[ads]) && !get_val(button[zoom])) {
			// If combo not running, execute it
			if(!combo_running(cboAutoFocus)) {
				combo_run(cboAutoFocus);
			}
		} else {
			// If not aiming and combo running, stop it
			if(combo_running(cboAutoFocus)) {
				combo_stop(cboAutoFocus);	
			}
		}
	}
	
	// Rapid Fire
	if(rapidFire[currentProfile] && get_val(button[fire])) {
		// Only run combo if it is not already running
		if(!combo_running(cboRapidFire)) {
			combo_run(cboRapidFire);		
		}
	} else if(combo_running(cboRapidFire)) { // Stop combo if doesn't conditions
		combo_stop(cboRapidFire);
	}
}


// Checks if the user is pausing the script (enter vehicle mode)
function checkPause() {
	// Check if user is holding Drive + tapping Up twice to pause the script
	if(get_val(button[fire]) && event_release(XB1_UP) && get_brtime(XB1_UP) <= 300) {
		scriptPaused = !scriptPaused; // Enable vehicle mode
		screenSaverCounter = 0; // Reset screen saver timer
		
		// Display Vehicle Mode message
		cls_oled(OLED_BLACK);
		printText(alignCenter, alignCenter, scriptPausedMsg[0], OLED_FONT_SMALL, OLED_WHITE);
		
		// If screen saver enabled, disable it
		if(screenSaverEnabled) {
			screenSaverEnabled = !screenSaverEnabled;
		}
	}
	
	// Block button output
	if(get_val(button[fire])) {
		set_val(XB1_RIGHT, 0);
	}
	
	return scriptPaused;
}

// Checks if the user is unpausing the script (exit vehicle mode)
function checkUnpause() {
	// Exiting a vehicle unpauses the script
	if(event_press(XB1_B)) {
		scriptPaused = !scriptPaused; // Disable vehicle mode
		homeUpdate = !homeUpdate; // Enable home screen update
		
		// Disable vehicle mode notification
		if(combo_running(cboScriptPaused)) {
			combo_stop(cboScriptPaused);
		}
	} else {
		combo_run(cboScriptPaused); // Enable vehicle mode notification
	}
}

// Correct stick input based on drift low/high values including deadzone and compensate for "lost" values
function correctStickInput(low, high, deadzone, stick) {
	// Calculate the boundaries
	antiDriftLowValue = low - polarValues[deadzone];
	antiDriftHighValue = high + polarValues[deadzone];
	antiDriftStickValue = get_val(stick); // Get stick value
	
	// In the drift zone, so set stick to no movement
	if((antiDriftStickValue >= antiDriftLowValue) && (antiDriftStickValue <= antiDriftHighValue)) {
		set_val(stick, 0);
		
	// If user has moved stick under the lower boundary (left/up)
	} else if(antiDriftStickValue < antiDriftLowValue) {
		set_val(stick, clamp((antiDriftStickValue - antiDriftLowValue) - ((antiDriftStickValue / 327) * antiDriftLowValue) / 100, -32768, 32767));
		
	// If user has moved stick over the upper boundary (right/down)
	} else if(antiDriftStickValue > antiDriftHighValue) {
		set_val(stick, clamp((antiDriftStickValue - antiDriftHighValue) + ((antiDriftStickValue / 327) * antiDriftHighValue) / 100, -32768, 32767));
		
	// Just incase stick_value isn't in driftzone and doesn't meet other conditions
	// (i.e. calculations equate to low/high value)
	// At that point we still do not want to make any adjustment because we're not outside of the drift+deadzone
	} else {
		set_val(stick, 0);
	}
}

// Creates a toggle combination
function createToggle(toggle) {
	// Loop through each controllerButtons and see what is being held down for 1 second
	for(i = 0; i < 13; i++) {	
		if(get_val(controllerButtons[i]) && (get_ptime(controllerButtons[i]) >= 1000)) {
			if(!editMenuSelectedRow) {
				// Setting HOLD
				varToggleButton[toggle] = setToggleButton(varToggleButton[toggle], controllerButtons[i], varToggleButton[toggle + 1]);
				varToggleButton[toggle] = verifyToggleCombo(varToggleButton[toggle], toggle);
			} else {
				// Setting PRESS
				varToggleButton[toggle + 1] = setToggleButton(varToggleButton[toggle + 1], controllerButtons[i], varToggleButton[toggle]);
				varToggleButton[toggle + 1] = verifyToggleCombo(varToggleButton[toggle + 1], toggle);
			}
		}
	}
}

// Cycles the edit menu
function cycleEditMenu(direction) {
	// Enable edit menu display update
	editMenuUpdate = !editMenuUpdate; 
	// Determine action from user
	switch(direction) {
		case editMenuAction {
			if(editMenuIndex == editMenuAntidriftCalibration && !antiDriftCalibrationState) {
				if(antiDriftCalibrationStick == antiDriftLeftStick) {
					varAntidriftLeft[antiDriftCalibrationDirection] = 0;
				} else {
					varAntidriftRight[antiDriftCalibrationDirection] = 0;
				}
				antiDriftCalibrationCanSet = 3;
				combo_run(cboCalibrationComplete); // Alert user of status
				antiDriftCalibrationState = !antiDriftCalibrationState; // Keep process disabled as combo will flop this value positive
			} else {
				menuActionFailed();
			}
			break;
		} case editMenuEnter { // Used for anti-drift calibration
			if(editMenuIndex == editMenuAntidriftCalibration && antiDriftCalibrationState) {
				// Only set if range was met
				if(antiDriftCalibrationCanSet) {
					determineAntidriftValue(); // Determine the value to set
				}
				combo_run(cboCalibrationComplete); // Alert user of status
			} else if(editMenuIndex == editMenuAntidriftCalibration) {
				antiDriftCalibrationState = !antiDriftCalibrationState; // Enter calibration process
			} else {
				menuActionFailed();
			}
			break;
		} case editMenuExit { // When user presses B/Circle
			if(editMenuIndex == editMenuAntidriftCalibration && antiDriftCalibrationState) {
				antiDriftCalibrationCanSet = 2; // Flag for cancelled
				combo_run(cboCalibrationComplete);
			} else {
				editMenu = !editMenu; // Disable edit menu
				editMenuUpdate = !editMenuUpdate; // Disable edit menu display update
				editMenuSelectedRow = 0; // Reset selected item index
				// Check if we are in anti-recoil quick edit
				if(antiRecoilQuickEdit) {
					homeHide = !homeHide; // Enable home screen
					homeUpdate = !homeUpdate; // Enable home display update
					antiRecoilQuickEdit = !antiRecoilQuickEdit; // Disable anti-recoil quick edit
					combo_run(cboSaveSettings); // Save settings
				} else {
					modMenu = !modMenu; // Enable mod menu
					modMenuUpdate = !modMenuUpdate; // Enable mod menu update
				}
			}
			editMenuSelectedPage = 0;
			editMenuSelectedRow = 0;
			editMenuSelectedColumn = 0;
			editMenuIndex = 0; // Reset edit menu index
			break;
		} case editMenuNextPage { // When user presses RB
			if((editMenuIndex == editMenuAntidriftCalibration) && (antiDriftCalibrationStick != antiDriftRightStick) && !antiDriftCalibrationState) {
				antiDriftCalibrationStick = antiDriftRightStick;
			} else if(hasValues(currentWeapon[menuProfile])) {
				editMenuSelectedPage = !editMenuSelectedPage;
			} else {
				menuActionFailed();
			}
			break;
		} case editMenuPreviousPage { // When user presses LB
			if((editMenuIndex == editMenuAntidriftCalibration) && (antiDriftCalibrationStick != antiDriftLeftStick) && !antiDriftCalibrationState) {
				antiDriftCalibrationStick = antiDriftLeftStick;
			} else if(hasValues(currentWeapon[menuProfile])) {
				editMenuSelectedPage = !editMenuSelectedPage;
			} else {
				menuActionFailed();
			}
			break;
		} case editMenuLeft { // When user presses Dpad-Left
			if(get_val(button[ads])) { // When user is holding ADS
				if(editMenuIndex == editMenuAntiRecoil) {// (Anti Recoil) Strengths
					if(!editMenuSelectedPage) { // Vertical values
						if(!editMenuSelectedColumn) { // Strength values
							if(editMenuSelectedRow == 0) {
								varAntiRecoilStart[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilStart[currentWeapon[menuProfile]], cycleValueDown, 1, 0);
							} else if(editMenuSelectedRow == 1) {
								if(hasValues(currentWeapon[menuProfile])) {
									varAntiRecoilMid[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilMid[currentWeapon[menuProfile]], cycleValueDown, 1, 0);
								} else {
									varRapidFireRecoil[currentWeapon[menuProfile]] = cycleEditValue(varRapidFireRecoil[currentWeapon[menuProfile]], cycleValueDown, 1, 0) 
								}
							} else if(editMenuSelectedRow == 2) {
								if(hasValues(currentWeapon[menuProfile])) {
									varAntiRecoilEnd[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilEnd[currentWeapon[menuProfile]], cycleValueDown, 1, 0);
								} else {
									varRapidFireSpeed = cycleEditValue(varRapidFireSpeed, cycleValueDown, 1, 1) 
								}
							}
						} else { // Time values
							if(editMenuSelectedRow == 0) {
								varAntiRecoilStartTime[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilStartTime[currentWeapon[menuProfile]], cycleValueDown, 1, 0);
							} else if(editMenuSelectedRow == 1) {
								varAntiRecoilMidTime[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilMidTime[currentWeapon[menuProfile]], cycleValueDown, 1, 0);
							}
						}
					} else { // Horizontal values
						if(!editMenuSelectedColumn) { // Strength values
							if(editMenuSelectedRow == 0) {
								varAntiRecoilStart_H[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilStart_H[currentWeapon[menuProfile]], cycleValueDown, 1, -100);
							} else if(editMenuSelectedRow == 1) {
								varAntiRecoilMid_H[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilMid_H[currentWeapon[menuProfile]], cycleValueDown, 1, -100);
							} else if(editMenuSelectedRow == 2) {
								varAntiRecoilEnd_H[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilEnd_H[currentWeapon[menuProfile]], cycleValueDown, 1, -100);
							}
						} else { // Time values
							if(editMenuSelectedRow == 0) {
								varAntiRecoilStartTime_H[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilStartTime_H[currentWeapon[menuProfile]], cycleValueDown, 1, 0);
							} else if(editMenuSelectedRow == 1) {
								varAntiRecoilMidTime_H[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilMidTime_H[currentWeapon[menuProfile]], cycleValueDown, 1, 0);
							}
						}
					}
				} else if(editMenuIndex == editMenuAntidriftCalibration && !antiDriftCalibrationState) { // (Anti-drift) Set direction
					if(antiDriftCalibrationDirection != antiDriftLeft) {
						antiDriftCalibrationDirection = antiDriftLeft;
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuProfileColors) { // (Profiles) Profile Colors
					varProfileColor[editMenuSelectedRow] = cycleListOption(varProfileColor[editMenuSelectedRow], cycleValueDown, red, pink);
				} else if(editMenuIndex == editMenuDeadzone) { // Controller deadzone
					varDeadzone[editMenuSelectedRow] = cycleEditValue(varDeadzone[editMenuSelectedRow], cycleValueDown, 1, 0);
				} else {
					menuActionFailed();
				}
			} else { // Cycle options
				if(editMenuIndex == editMenuAntiRecoil) {
					if(hasValues(currentWeapon[menuProfile])) {
						editMenuSelectedColumn = cycleEditValue(editMenuSelectedColumn, cycleValueDown, 1, 0);
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuAntidrift && !varAntidrift) {
					menuActionFailed(); // Anti-drift must be enabled to see rest of options
				} else if(editMenuIndex == editMenuAntidriftCalibration && antiDriftCalibrationState) {
					menuActionFailed(); // Cannot leave calibration menu if calibration is running
				} else {
					editMenuSelectedRow = 0; // Reset selected item index
					editMenuSelectedColumn = 0;
					editMenuIndex = cycleListOption(editMenuIndex, cycleValueDown, editMenuItems[modMenuIndex][editMenuMin], editMenuItems[modMenuIndex][editMenuMax]);
				
				}
			}
			break;
		} case editMenuRight { // When user presses DPad-Right
			if(get_val(button[ads])) { // When user holds ADS
				if(editMenuIndex == editMenuAntiRecoil) {// (Anti Recoil) Strengths
					if(!editMenuSelectedPage) { // Vertical values
						if(!editMenuSelectedColumn) { // Strength values
							if(editMenuSelectedRow == 0) {
								varAntiRecoilStart[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilStart[currentWeapon[menuProfile]], cycleValueUp, 1, 100);
							} else if(editMenuSelectedRow == 1) {
								if(hasValues(currentWeapon[menuProfile])) {
									varAntiRecoilMid[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilMid[currentWeapon[menuProfile]], cycleValueUp, 1, 100);
								} else {
									varRapidFireRecoil[currentWeapon[menuProfile]] = cycleEditValue(varRapidFireRecoil[currentWeapon[menuProfile]], cycleValueUp, 1, 100);
								}
							} else if(editMenuSelectedRow == 2) {
								if(hasValues(currentWeapon[menuProfile])) {
									varAntiRecoilEnd[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilEnd[currentWeapon[menuProfile]], cycleValueUp, 1, 100);
								} else {
									varRapidFireSpeed = cycleEditValue(varRapidFireSpeed, cycleValueUp, 1, 30);
								}
							}
						} else {
							if(editMenuSelectedRow == 0) {
								varAntiRecoilStartTime[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilStartTime[currentWeapon[menuProfile]], cycleValueUp, 1, 100);
							} else if(editMenuSelectedRow == 1) {
								varAntiRecoilMidTime[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilMidTime[currentWeapon[menuProfile]], cycleValueUp, 1, 100);
							}
						}
					} else { // Horizontal values
						if(!editMenuSelectedColumn) { // Strength values
							if(editMenuSelectedRow == 0) {
								varAntiRecoilStart_H[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilStart_H[currentWeapon[menuProfile]], cycleValueUp, 1, 100);
							} else if(editMenuSelectedRow == 1) {
								varAntiRecoilMid_H[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilMid_H[currentWeapon[menuProfile]], cycleValueUp, 1, 100);
							} else if(editMenuSelectedRow == 2) {
								varAntiRecoilEnd_H[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilEnd_H[currentWeapon[menuProfile]], cycleValueUp, 1, 100);
							}
						} else {
							if(editMenuSelectedRow == 0) {
								varAntiRecoilStartTime_H[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilStartTime_H[currentWeapon[menuProfile]], cycleValueUp, 1, 100);
							} else if(editMenuSelectedRow == 1) {
								varAntiRecoilMidTime_H[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilMidTime_H[currentWeapon[menuProfile]], cycleValueUp, 1, 100);
							}
						}
					}
				} else if(editMenuIndex == editMenuAntidriftCalibration && !antiDriftCalibrationState) { // (Anti-drift) Set direction
					if(antiDriftCalibrationDirection != antiDriftRight) {
						antiDriftCalibrationDirection = antiDriftRight;
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuProfileColors) { // (Profiles) Profile Colors
					varProfileColor[editMenuSelectedRow] = cycleListOption(varProfileColor[editMenuSelectedRow], cycleValueUp, pink, red);
				} else if(editMenuIndex == editMenuDeadzone) { // Controller deadzone
					varDeadzone[editMenuSelectedRow] = cycleEditValue(varDeadzone[editMenuSelectedRow], cycleValueUp, 1, 30);
				} else {
					menuActionFailed();
				}
			} else { // Cycle options
				if(editMenuIndex == editMenuAntiRecoil) {
					if(hasValues(currentWeapon[menuProfile]) && editMenuSelectedRow != 2) {
						editMenuSelectedColumn = cycleEditValue(editMenuSelectedColumn, cycleValueUp, 1, 1);
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuAntidrift && !varAntidrift) {
					menuActionFailed(); // Anti-drift must be enabled to see rest of options
				} else if(editMenuIndex == editMenuAntidriftCalibration && antiDriftCalibrationState) {
					menuActionFailed(); // Cannot leave calibration menu if calibration is running
				} else {
					editMenuSelectedRow = 0; // Reset selected item index
					editMenuSelectedColumn = 0;
					editMenuIndex = cycleListOption(editMenuIndex, cycleValueUp, editMenuItems[modMenuIndex][editMenuMax], editMenuItems[modMenuIndex][editMenuMin]);
	
				}
			}
			break;
		} case editMenuUp { // When user presses DPad-Up
			if(get_val(button[ads])) { // When user holds ADS
				if(editMenuIndex == editMenuAntiRecoil) {// (Anti Recoil) Strengths
					if(!editMenuSelectedPage) { // Vertical values
						if(!editMenuSelectedColumn) { // Strength values
							if(editMenuSelectedRow == 0) {
								varAntiRecoilStart[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilStart[currentWeapon[menuProfile]], cycleValueUp, 10, 100);
							} else if(editMenuSelectedRow == 1) {
								if(hasValues(currentWeapon[menuProfile])) {
									varAntiRecoilMid[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilMid[currentWeapon[menuProfile]], cycleValueUp, 10, 100);
								} else {
									varRapidFireRecoil[currentWeapon[menuProfile]] = cycleEditValue(varRapidFireRecoil[currentWeapon[menuProfile]], cycleValueUp, 10, 100); 
								}
							} else if(editMenuSelectedRow == 2) {
								if(hasValues(currentWeapon[menuProfile])) {
									varAntiRecoilEnd[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilEnd[currentWeapon[menuProfile]], cycleValueUp, 10, 100);
								} else {
									varRapidFireSpeed = cycleEditValue(varRapidFireSpeed, cycleValueUp, 10, 30); 
								}
							}
						} else {
							if(editMenuSelectedRow == 0) {
								varAntiRecoilStartTime[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilStartTime[currentWeapon[menuProfile]], cycleValueUp, 10, 100);
							} else if(editMenuSelectedRow == 1) {
								varAntiRecoilMidTime[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilMidTime[currentWeapon[menuProfile]], cycleValueUp, 10, 100);
							}
						}
					} else { // Horizontal values
						if(!editMenuSelectedColumn) { // Strength values
							if(editMenuSelectedRow == 0) {
								varAntiRecoilStart_H[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilStart_H[currentWeapon[menuProfile]], cycleValueUp, 10, 100);
							} else if(editMenuSelectedRow == 1) {
								varAntiRecoilMid_H[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilMid_H[currentWeapon[menuProfile]], cycleValueUp, 10, 100);
							} else if(editMenuSelectedRow == 2) {
								varAntiRecoilEnd_H[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilEnd_H[currentWeapon[menuProfile]], cycleValueUp, 10, 100);
							}
						} else {
							if(editMenuSelectedRow == 0) {
								varAntiRecoilStartTime_H[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilStartTime_H[currentWeapon[menuProfile]], cycleValueUp, 10, 100);
							} else if(editMenuSelectedRow == 1) {
								varAntiRecoilMidTime_H[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilMidTime_H[currentWeapon[menuProfile]], cycleValueUp, 10, 100);
							}
						}
					}
				} else if(editMenuIndex == editMenuAntidriftCalibration && !antiDriftCalibrationState) { // (Anti-drift) Set direction
					if(antiDriftCalibrationDirection != antiDriftUp) {
						antiDriftCalibrationDirection = antiDriftUp;
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuDeadzone) { // Controller deadzone
					varDeadzone[editMenuSelectedRow] = cycleEditValue(varDeadzone[editMenuSelectedRow], cycleValueUp, 10, 30);
				} else {
					menuActionFailed();
				}
			} else { // Cycle options
				if(editMenuIndex == editMenuAntiRecoil) { // Anti-recoil
					if(currentWeapon[menuProfile] < sniper) {
						editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueDown, 1, 0);
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuAntidrift) { // (Anti-drift)
					varAntidrift = !varAntidrift;
				} else if(editMenuIndex == editMenuControllerButtonLayout) { // (Controller) Button Layout
					varControllerButtonLayout = cycleListOption(varControllerButtonLayout, cycleValueUp, cblTypeC, cblTypeA);
					setButtonLayout(); // Refresh button layout
				} else if(editMenuIndex == editMenuAutoFocus) { // (Options) Auto Focus
					varAutoFocus[menuProfile] = !varAutoFocus[menuProfile];
				} else if(editMenuIndex == editMenuProfileSwitch) { // (Profiles) Profile Buttons
					editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueDown, 1, 0);
				} else if(editMenuIndex == editMenuProfileColors) { // (Profiles) Profile Colors
					editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueDown, 1, 0);
				} else if(editMenuIndex == editMenuBlockRumble) { // (Settings) Block Rumble
					varBlockRumble = !varBlockRumble;
				} else if(editMenuIndex == editMenuDeadzone) { // (Settings) Deadzone
					editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueDown, 1, 0);
				} else if(editMenuIndex == editMenuInverted) { // (Settings) Inverted
					varInverted = !varInverted;
				} else if(editMenuIndex == editMenuToggleRapidFire) { // (Toggles) Rapid Fire
					editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueDown, 1, 0);
				} else {
					menuActionFailed();
				}
			}
			break;
		} case editMenuDown { // When user presses DPad-Down
			if(get_val(button[ads])) { // When user holds ADS
				if(editMenuIndex == editMenuAntiRecoil) {// (Anti Recoil) Strengths
					if(!editMenuSelectedPage) { // Vertical values
						if(!editMenuSelectedColumn) { // Strength values
							if(editMenuSelectedRow == 0) {
								varAntiRecoilStart[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilStart[currentWeapon[menuProfile]], cycleValueDown, 10, 0);
							} else if(editMenuSelectedRow == 1) {
								if(hasValues(currentWeapon[menuProfile])) {
									varAntiRecoilMid[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilMid[currentWeapon[menuProfile]], cycleValueDown, 10, 0);
								} else {
									varRapidFireRecoil[currentWeapon[menuProfile]] = cycleEditValue(varRapidFireRecoil[currentWeapon[menuProfile]], cycleValueDown, 10, 0); 
								}
							} else if(editMenuSelectedRow == 2) {
								if(hasValues(currentWeapon[menuProfile])) {
									varAntiRecoilEnd[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilEnd[currentWeapon[menuProfile]], cycleValueDown, 10, 0);
								} else {
									varRapidFireSpeed = cycleEditValue(varRapidFireSpeed, cycleValueDown, 10, 1); 
								}
							}
						} else {
							if(editMenuSelectedRow == 0) {
								varAntiRecoilStartTime[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilStartTime[currentWeapon[menuProfile]], cycleValueDown, 10, 0);
							} else if(editMenuSelectedRow == 1) {
								varAntiRecoilMidTime[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilMidTime[currentWeapon[menuProfile]], cycleValueDown, 10, 0);
							}
						}
					} else { // Horizontal values
						if(!editMenuSelectedColumn) { // Strength values
							if(editMenuSelectedRow == 0) {
								varAntiRecoilStart_H[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilStart_H[currentWeapon[menuProfile]], cycleValueDown, 10, -100);
							} else if(editMenuSelectedRow == 1) {
								varAntiRecoilMid_H[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilMid_H[currentWeapon[menuProfile]], cycleValueDown, 10, -100);
							} else if(editMenuSelectedRow == 2) {
								varAntiRecoilEnd_H[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilEnd_H[currentWeapon[menuProfile]], cycleValueDown, 10, -100);
							}
						} else {
							if(editMenuSelectedRow == 0) {
								varAntiRecoilStartTime_H[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilStartTime_H[currentWeapon[menuProfile]], cycleValueDown, 10, 0);
							} else if(editMenuSelectedRow == 1) {
								varAntiRecoilMidTime_H[currentWeapon[menuProfile]] = cycleEditValue(varAntiRecoilMidTime_H[currentWeapon[menuProfile]], cycleValueDown, 10, 0);
							}
						}
					}
				} else if(editMenuIndex == editMenuAntidriftCalibration && !antiDriftCalibrationState) { // (Anti-drift) Set direction
					if(antiDriftCalibrationDirection != antiDriftDown) {
						antiDriftCalibrationDirection = antiDriftDown;
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuDeadzone) { // Controller deadzone
					varDeadzone[editMenuSelectedRow] = cycleEditValue(varDeadzone[editMenuSelectedRow], cycleValueDown, 10, 0);
				} else {
					menuActionFailed();
				}
			} else { // Cycle options
				if(editMenuIndex == editMenuAntiRecoil) { // Anti-recoil
					if((currentWeapon[menuProfile] < sniper) && !(editMenuSelectedColumn == 1 && editMenuSelectedRow == 1)) {
						editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueUp, 1, 2);
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuAntidrift) { // (Anti-drift)
					varAntidrift = !varAntidrift;
				} else if(editMenuIndex == editMenuControllerButtonLayout) { // (Controller) Button Layout
					varControllerButtonLayout = cycleListOption(varControllerButtonLayout, cycleValueDown, cblTypeA, cblTypeC);
					setButtonLayout(); // Refresh button layout
				} else if(editMenuIndex == editMenuAutoFocus) { // (Options) Auto Focus
					varAutoFocus[menuProfile] = !varAutoFocus[menuProfile];
				} else if(editMenuIndex == editMenuProfileSwitch) { // (Profiles) Profile Buttons
					editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueUp, 1, 1);
				} else if(editMenuIndex == editMenuProfileColors) { // (Profiles) Profile Colors
					editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueUp, 1, 1);
				} else if(editMenuIndex == editMenuBlockRumble) { // (Settings) Block Rumble
					varBlockRumble = !varBlockRumble;
				} else if(editMenuIndex == editMenuDeadzone) { // (Settings) Deadzone
					editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueUp, 1, 1);
				} else if(editMenuIndex == editMenuInverted) { // (Settings) Inverted
					varInverted = !varInverted;
				} else if(editMenuIndex == editMenuToggleRapidFire) { // (Toggles) Rapid Fire
					editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueUp, 1, 1);
				} else {
					menuActionFailed();
				}
			}
			break;
		}
	}
}

// Cycle an edit menu value by step amount with change limited to a threshold
function cycleEditValue(value, direction, step, threshold) {
	// See what direction we are cycling the values
	if(direction == cycleValueUp) {
		if((value + step) <= threshold) {
			return (value + step);
		} else if(value == threshold) {
			menuActionFailed();
		} else {
			return threshold;
		}
	} else {
		if((value - step) >= threshold) {
			return (value - step);
		} else if(value == threshold) {
			menuActionFailed();
		} else {
			return threshold;
		}
	}
	
	return value;
}

// Cycle a menu value
function cycleListOption(value, direction, threshold, reset_value) {
	// See what direction we are cycling the values
	if(direction == cycleValueUp) {
		if((value + 1) <= threshold) {
			return value + 1;
		}
	} else {
		if((value - 1) >= threshold) {
			return value - 1;
		}
	}
	
	return reset_value;
}

// Cycle mod menu value
function cycleModMenu(direction) {
	// Update mod menu
	modMenuUpdate = !modMenuUpdate;
	// Determine action and handle it accordingly
	switch(direction) {
		case modMenuEnter {
			modMenu = !modMenu; // Disable mod menu
			editMenu = !editMenu; // Enable edit menu
			modMenuUpdate = !modMenuUpdate; // Disable mod menu update
			editMenuUpdate = !editMenuUpdate; // Enable edit menu update
			editMenuIndex = editMenuItems[modMenuIndex][editMenuMin]; // Set new edit menu index
			break;
		} case modMenuExit {
			homeHide = !homeHide; // Enable home screen
			modMenu = !modMenu; // Disable mod menu
			modMenuUpdate = !modMenuUpdate; // Disable mod menu update
			combo_run(cboSaveSettings); // Save settings upon exiting mod menu
			break;
		} case modMenuDown {
			modMenuIndex++; // Cycle to next menu
			if(modMenuIndex > modMenuMax) { // Check boundaries
				modMenuIndex = modMenuMin; // Out of bounds, set to minimum
			}
			menuActionSuccess(); // Alert for successful action
			break;
		} case modMenuUp {
			modMenuIndex--; // Cycle to previous menu
			if(modMenuIndex < modMenuMin) { // Check boundaries
				modMenuIndex = modMenuMax; // Out of bounds, set to maximum
			}
			menuActionSuccess(); // Alert for successful action
			break;
		}
	}
}

// Determines what to set the anti-drift value to, if a new value was found
function determineAntidriftValue() {
	if(antiDriftCalibrationStick == antiDriftLeftStick) {
		switch(antiDriftCalibrationDirection) {
			case antiDriftUp {
				antiDriftCalibrationValue = get_val(POLAR_LY);
				if((antiDriftCalibrationValue < varAntidriftLeft[antiDriftUp]) || (varAntidriftLeft[antiDriftUp] == 0)) {
					varAntidriftLeft[antiDriftUp] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftDown {
				antiDriftCalibrationValue = get_val(POLAR_LY);
				if((antiDriftCalibrationValue > varAntidriftLeft[antiDriftDown]) || (varAntidriftLeft[antiDriftDown] == 0)) {
					varAntidriftLeft[antiDriftDown] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftLeft {
				antiDriftCalibrationValue = get_val(POLAR_LX);
				if((antiDriftCalibrationValue < varAntidriftLeft[antiDriftLeft]) || (varAntidriftLeft[antiDriftLeft] == 0)) {
					varAntidriftLeft[antiDriftLeft] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftRight {
				antiDriftCalibrationValue = get_val(POLAR_LX);
				if((antiDriftCalibrationValue > varAntidriftLeft[antiDriftRight]) || (varAntidriftLeft[antiDriftRight] == 0)) {
					varAntidriftLeft[antiDriftRight] = antiDriftCalibrationValue;
				}
				break;
			}
		}
	} else {
		switch(antiDriftCalibrationDirection) {
			case antiDriftUp {
				antiDriftCalibrationValue = get_val(POLAR_RY);
				if((antiDriftCalibrationValue < varAntidriftRight[antiDriftUp]) || (varAntidriftRight[antiDriftUp] == 0)) {
					varAntidriftRight[antiDriftUp] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftDown {
				antiDriftCalibrationValue = get_val(POLAR_RY);
				if((antiDriftCalibrationValue > varAntidriftRight[antiDriftDown]) || (varAntidriftRight[antiDriftDown] == 0)) {
					varAntidriftRight[antiDriftDown] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftLeft {
				antiDriftCalibrationValue = get_val(POLAR_RX);
				if((antiDriftCalibrationValue < varAntidriftRight[antiDriftLeft]) || (varAntidriftRight[antiDriftLeft] == 0)) {
					varAntidriftRight[antiDriftLeft] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftRight {
				antiDriftCalibrationValue = get_val(POLAR_RX);
				if((antiDriftCalibrationValue > varAntidriftRight[antiDriftRight]) || (varAntidriftRight[antiDriftRight] == 0)) {
					varAntidriftRight[antiDriftRight] = antiDriftCalibrationValue;
				}
				break;
			}
		}
	}
}

// Handles a pressed toggle combination sequence
function dispatchToggle(id) {
	switch(id) {
		case toggleProfile {
			switchProfile(!currentProfile); // Switch profiles
			break;	
		} case toggleRapidFire {
			rapidFire[currentProfile] = !rapidFire[currentProfile];
			// Disable combo if it is running
			if(combo_running(cboToggleRapidFire)) {
				combo_stop(cboToggleRapidFire);
			}
			// Run combo to alert user
			combo_run(cboToggleRapidFire);
			break;
		}
	}
}

// Displays stick values for the Anti-drift Test menu
function displayAntidriftTest(x, y, line) {
	// Build display
	insertCharacter(iif(x == POLAR_LX, ASCII_UPPER_L, ASCII_UPPER_R));
	insertCharacter(ASCII_COLON);
	insertCharacter(ASCII_SPACE);
	insertNumber(get_val(x));
	insertCharacter(ASCII_COMMA);
	insertNumber(get_val(y));
	flushBuffer(alignLeft, line, OLED_FONT_SMALL, OLED_WHITE);
}

// Displays the current anti-drift X/Y values for both sticks
function displayAntidriftValues() {
	// Draw a separator line down middle of OLED
	line_oled(OLED_WIDTH >> 1, lineNumber[0] - 4, OLED_WIDTH >> 1, OLED_HEIGHT - 2, 1, OLED_WHITE);
	// Draw each value
	for(j = 0; j < 4; j++) {
		// Left stick
		insertString(antiDriftValues[j]);
		insertNumber(varAntidriftLeft[j]);
		flushBuffer(alignLeft - 2, 21 + (j * 10), OLED_FONT_SMALL, OLED_WHITE);
		// Right stick
		insertString(antiDriftValues[j]);
		insertNumber(varAntidriftRight[j]);
		flushBuffer((OLED_WIDTH >> 1) + 3, 21 + (j * 10), OLED_FONT_SMALL, OLED_WHITE);
	}
}

// Draws the 'Anti Recoil' selection menu
function displayAntiRecoilSelection() {
	if(currentWeapon[menuProfile] < sniper) {
		if(hasValues(currentWeapon[menuProfile])) {
			// Draw selected item background
			rect_oled(alignLeft - 2, lineNumber[editMenuSelectedRow] - 2, (OLED_WIDTH >> 1) +( OLED_FONT_SMALL_WIDTH * 2) - 4, OLED_FONT_SMALL_HEIGHT + 3, 0, iif(editMenuSelectedColumn, OLED_BLACK, OLED_WHITE));
			rect_oled(OLED_WIDTH - (OLED_WIDTH >> 1) + (OLED_FONT_SMALL_WIDTH * 2) + 2, lineNumber[editMenuSelectedRow] - 2, (OLED_WIDTH >> 1) - 5 - (OLED_FONT_SMALL_WIDTH * 2), OLED_FONT_SMALL_HEIGHT + 3, 0, iif(editMenuSelectedColumn, OLED_WHITE, OLED_BLACK));
		} else if(currentWeapon[menuProfile] < sniper) {
			rect_oled(alignLeft - 2, lineNumber[editMenuSelectedRow] - 2, OLED_WIDTH - 6, OLED_FONT_SMALL_HEIGHT + 3, 0, iif(editMenuSelectedColumn, OLED_BLACK, OLED_WHITE));
		}
		// Loop through each anti-recoil variable and display the strength/timer
		for(j = 0; j < 3; j++) {
			// Build left side
			if(hasValues(currentWeapon[menuProfile])) {
				insertString(iif(editMenuSelectedPage, recoilMenu[j + 3], recoilMenu[j]));
			} else if(currentWeapon[menuProfile] < sniper) {
				insertString(recoilMenu[j + 6]);
			}
			if(hasValues(currentWeapon[menuProfile])) {
				if(j == 0 ) {
					insertNumber(iif(editMenuSelectedPage, varAntiRecoilStart_H[currentWeapon[menuProfile]], varAntiRecoilStart[currentWeapon[menuProfile]]));
				} else if(j == 1) {
					insertNumber(iif(editMenuSelectedPage, varAntiRecoilMid_H[currentWeapon[menuProfile]], varAntiRecoilMid[currentWeapon[menuProfile]]));
				} else if(j == 2) {
					insertNumber(iif(editMenuSelectedPage, varAntiRecoilEnd_H[currentWeapon[menuProfile]], varAntiRecoilEnd[currentWeapon[menuProfile]]));
				}
			} else {
				if(j == 0 ) {
					insertNumber(varAntiRecoilStart[currentWeapon[menuProfile]]);
				} else if(j == 1) {
					insertNumber(varRapidFireRecoil[currentWeapon[menuProfile]]);
				} else if(j == 2) {
					insertNumber(varRapidFireSpeed);
				}
			}
			
			if(((j == 0) || (hasValues(currentWeapon[menuProfile])))) {
				flushBuffer(alignLeft, lineNumber[j], OLED_FONT_SMALL, OLED_WHITE);
			} else if(currentWeapon[menuProfile] < sniper) {
				flushBuffer(alignLeft, lineNumber[j], OLED_FONT_SMALL, OLED_WHITE);
			}
			
			// Build right side
			if(hasValues(currentWeapon[menuProfile])) {
				if(j == 0) {
					insertNumber(iif(editMenuSelectedPage, varAntiRecoilStartTime_H[currentWeapon[menuProfile]], varAntiRecoilStartTime[currentWeapon[menuProfile]]) * 10);
				} else if(j == 1) {
					insertNumber(iif(editMenuSelectedPage, varAntiRecoilMidTime_H[currentWeapon[menuProfile]], varAntiRecoilMidTime[currentWeapon[menuProfile]]) * 10);
				}
				
				// Append "ms" to times
				if(j != 2) {
					insertCharacter(ASCII_LOWER_M);
					insertCharacter(ASCII_LOWER_S);
				}
			}
			
			// Determine selected item
			if(((j == 0) || (hasValues(currentWeapon[menuProfile]))) /*&& (currentWeapon[menuProfile] < sniper)*/) {
				flushBuffer(OLED_WIDTH - (OLED_WIDTH >> 1) + (OLED_FONT_SMALL_WIDTH * 2) + 4, lineNumber[j], OLED_FONT_SMALL, OLED_WHITE);
			}
		}
	}
}

// Draws a list of two items and highlights the selected item
function displayDualSelection(type, message1, message2, value1, value2) {
	
	// Draw selected item background
	rect_oled(alignLeft, lineNumber[editMenuSelectedRow] - 1, OLED_WIDTH - 9, OLED_FONT_SMALL_HEIGHT + 1, 1, OLED_WHITE);
	
	// Generate first item
	buildSelectedItemBuffer(type, message1, value1);
	flushSelectedItemBuffer(0, lineNumber[0]);
	
	// Generate second item
	buildSelectedItemBuffer(type, message2, value2);
	flushSelectedItemBuffer(1, lineNumber[1]);
}

// Display edit menu
function displayEditMenu() {

 	drawBorder(); // Clears the screen and draws a border
 	
 	// Will be 2 if user is setting toggle buttons
 	if(editMenuUpdate != 2 && !antiDriftCalibrationState && editMenuIndex != editMenuAntidriftTest) { 
  		menuActionSuccess();
	}
	
	// Display either the weapon name being edited or the name of the menu and draw a line for formatting
	printText(alignCenter, alignTop, iif(editMenuIndex == editMenuAntiRecoil, weaponName[currentWeapon[menuProfile]], editMenuNames[editMenuIndex]), OLED_FONT_SMALL, OLED_WHITE); 
	line_oled(1, OLED_FONT_SMALL_HEIGHT + 7, 127, OLED_FONT_SMALL_HEIGHT + 7, 1, OLED_WHITE);
	
	// See if we should draw a line and display profile name
	if(editMenuItems[modMenuIndex][editMenuShowProfile]) {
		line_oled(1, OLED_HEIGHT - OLED_FONT_SMALL_HEIGHT - 7, 127, OLED_HEIGHT - OLED_FONT_SMALL_HEIGHT - 7, 1, OLED_WHITE); // Draw bottom line
		printText(alignCenter, alignBottom, weaponName[currentWeapon[menuProfile]], OLED_FONT_SMALL, OLED_WHITE); // Display profile name
	}
	
	// See what setting we must display
	switch (editMenuIndex) {
		case editMenuAntidrift { // (Anti-drift) Toggle On/Off
			printText(alignCenter, alignCenter, toggleOffOn[varAntidrift], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuAntidriftCalibration { // (Anti-drift) Calibration
			if(antiDriftCalibrationState) {
				// Calibration mode running
				printText(alignCenter, alignCenter, antiDriftCalibrationStateMsg[antiDriftCalibrationState], OLED_FONT_SMALL, OLED_WHITE);
			} else {
				// Calibration mode not running
				printText(alignCenter, lineNumber[0], antiDriftCalibrationStickPrompt[antiDriftCalibrationStick], OLED_FONT_SMALL, OLED_WHITE);
				printText(alignCenter, lineNumber[1], antiDriftCalibrationDirectionPrompt[antiDriftCalibrationDirection], OLED_FONT_SMALL, OLED_WHITE);
				rect_oled(alignLeft - 2, lineNumber[2], OLED_WIDTH - 6, OLED_FONT_SMALL_HEIGHT + 4, 1, OLED_WHITE);
				printText(alignCenter, lineNumber[2] + 3, antiDriftCalibrationStateMsg[antiDriftCalibrationState], OLED_FONT_SMALL, OLED_BLACK);
			}
			break;
		} case editMenuAntidriftTest { // (Anti-drift) Drift Test
			displayAntidriftTest(POLAR_LX, POLAR_LY, lineNumber[0]);
			displayAntidriftTest(POLAR_RX, POLAR_RY, lineNumber[1]);
			break;
		} case editMenuAntidriftValues { // (Anti-drift) Drift Values
			displayAntidriftValues();
			break;
		} case editMenuAntiRecoil { // (Anti Recoil)
			displayAntiRecoilSelection();
			break;
		} case editMenuControllerButtonLayout { // (Controller) Button Layout
			printText(alignCenter, alignCenter, buttonLayoutName[varControllerButtonLayout], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuAutoFocus { // (Options) Auto Focus
			printText(alignCenter, alignCenter, toggleOffOn[varAutoFocus[menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuProfileSwitch { // (Profiles) Profile Switch
			displayDualSelection(displayString, profileToggleMsg[0], profileToggleMsg[1], iif(get_controller() == PIO_PS4, controllerButtonsPS4[varToggleButton[toggleProfile]], controllerButtonsXBOX[varToggleButton[toggleProfile]]), iif(get_controller() == PIO_PS4, controllerButtonsPS4[varToggleButton[toggleProfile + 1]], controllerButtonsXBOX[varToggleButton[toggleProfile + 1]]));
			break;
		} case editMenuProfileColors { // (Profiles) Profile colors
			displayDualSelection(displayString, profileToggleMsg[4], profileToggleMsg[5], colorName[varProfileColor[0]], colorName[varProfileColor[1]]);
			break;
		} case editMenuBlockRumble { // (Settings) Block Rumble
			printText(alignCenter, alignCenter, toggleOffOn[varBlockRumble], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuDeadzone { // (Settings) Deadzone
			displayDualSelection(displayNumber, stickName[deadzoneLeft], stickName[deadzoneRight], varDeadzone[deadzoneLeft], varDeadzone[deadzoneRight]);
			break;
		} case editMenuInverted { // (Settings) Inverted
			printText(alignCenter, alignCenter, toggleOffOn[varInverted], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuToggleRapidFire { // (Toggles) Rapid Fire
			displayToggle(toggleRapidFire);
			break;
		}
	}
 }
 

// Display home screen
function displayHomeScreen() {

 	drawBorder(); // Clears the screen and draws a border
 	
	// Show home screen
	printText(alignCenter, 10, homeScreenMessages[homeScriptName], OLED_FONT_SMALL, OLED_WHITE);
	printText(alignCenter, 26, homeScreenMessages[homeScriptVersion], OLED_FONT_SMALL, OLED_WHITE);
	printText(alignCenter, 42, homeScreenMessages[homeScriptAuthor], OLED_FONT_SMALL, OLED_WHITE);
 }
 
 // Display mod menu
 function displayModMenu() {
 
 	drawBorder(); // Clears the screen and draws a border
  	menuActionSuccess(); // Alert for successful action
	
 	// Display the mod menu
	printText(alignCenter, alignTop, modMenuNames[modMenuItems[modMenuIndex][modMenuPrevious]], OLED_FONT_SMALL, OLED_WHITE);
	printText(alignCenter, alignCenter, modMenuNames[modMenuItems[modMenuIndex][modMenuCurrent]], OLED_FONT_MEDIUM, OLED_WHITE);
	printText(alignCenter, alignBottom, modMenuNames[modMenuItems[modMenuIndex][modMenuNext]], OLED_FONT_SMALL, OLED_WHITE);
 }

// Generates the display for editing toggles
function displayToggle(id) {
	if(get_controller() == PIO_PS4) {
		displayDualSelection(displayString, profileToggleMsg[2], profileToggleMsg[3], controllerButtonsPS4[varToggleButton[id]], controllerButtonsPS4[varToggleButton[id + 1]]);
	} else {
		displayDualSelection(displayString, profileToggleMsg[2], profileToggleMsg[3], controllerButtonsXBOX[varToggleButton[id]], controllerButtonsXBOX[varToggleButton[id + 1]]);
	}
}

// Clears the screen and draws a border around the OLED
function drawBorder() {
	cls_oled(OLED_BLACK); // Clear screen
	rect_oled(0, 0, 128, 63, 0, OLED_WHITE); // Draw border around OLED
}

int antiRecoilX, antiRecoilY;
int antiRecoilKickDurationX, antiRecoilKickDurationY;
int antiRecoilStateX, antiRecoilStateY;

// Execute anti-recoil
function executeAntiRecoil() {
	// Check vertical first
	if(!rapidFire[currentProfile]) {
		if(!antiRecoilStateY) {
			if(hasValues(currentWeapon[currentProfile])) {
				if(antiRecoilKickDurationY <= (varAntiRecoilStartTime[currentWeapon[currentProfile]] * 10)) {
					antiRecoilY = polarValues[varAntiRecoilStart[currentWeapon[currentProfile]] + get_rumble(RUMBLE_A)]; 
				} else {
					antiRecoilKickDurationY = 0; // Reset counter
					antiRecoilStateY++; // Advance to next stage
				}
			} else {
				antiRecoilY = polarValues[varAntiRecoilStart[currentWeapon[currentProfile]] + get_rumble(RUMBLE_A)];
			}
		}
		if(hasValues(currentWeapon[currentProfile])) {
			if(antiRecoilStateY == 1) {
				if(antiRecoilKickDurationY <= (varAntiRecoilMidTime[currentWeapon[currentProfile]] * 10)) {
					antiRecoilY = polarValues[varAntiRecoilMid[currentWeapon[currentProfile]] + get_rumble(RUMBLE_A)]; 
				} else {
					antiRecoilKickDurationY = 0; // Reset counter
					antiRecoilStateY++; // Advance to next stage
					antiRecoilY = polarValues[varAntiRecoilEnd[currentWeapon[currentProfile]] + get_rumble(RUMBLE_A)]; 
				}
			}
			if(antiRecoilStateY == 2) {
				antiRecoilY = polarValues[varAntiRecoilEnd[currentWeapon[currentProfile]] + get_rumble(RUMBLE_A)]; 
			}
		}
	} else {
		antiRecoilY = polarValues[varRapidFireRecoil[currentWeapon[currentProfile]] + get_rumble(RUMBLE_A)];
	}
	
	// Check horizontal
	if(hasValues(currentWeapon[currentProfile])) {
		if(!antiRecoilStateX) {
			if(antiRecoilKickDurationX <= (varAntiRecoilStartTime_H[currentWeapon[currentProfile]] * 10)) {
				if(varAntiRecoilStart_H[currentWeapon[currentProfile]] >= 0) {
					antiRecoilX = polarValues[varAntiRecoilStart_H[currentWeapon[currentProfile]] + get_rumble(RUMBLE_A)]; // Apply kick compensation
				} else {
					antiRecoilX = inv(polarValues[abs(varAntiRecoilStart_H[currentWeapon[currentProfile]]) - get_rumble(RUMBLE_A)]); // Apply kick compensation
				}
			} else {
				antiRecoilKickDurationX = 0; // Reset counter
				antiRecoilStateX++; // Advance to next stage
			}
		}else if(antiRecoilStateX == 1) {
			if(antiRecoilKickDurationX <= (varAntiRecoilMidTime_H[currentWeapon[currentProfile]] * 10)) {
				if(varAntiRecoilMid_H[currentWeapon[currentProfile]] >= 0) {
					antiRecoilX = polarValues[varAntiRecoilMid_H[currentWeapon[currentProfile]] + get_rumble(RUMBLE_A)]; // Apply kick compensation
				} else {
					antiRecoilX = inv(polarValues[abs(varAntiRecoilMid_H[currentWeapon[currentProfile]]) - get_rumble(RUMBLE_A)]); // Apply kick compensation
				}
			} else {
				antiRecoilKickDurationX = 0; // Reset counter
				antiRecoilStateX++; // Advance to next stage
			}
		} else if(antiRecoilStateX == 2) {
			if(varAntiRecoilEnd_H[currentWeapon[currentProfile]] >= 0) {
				antiRecoilX = polarValues[varAntiRecoilEnd_H[currentWeapon[currentProfile]] + get_rumble(RUMBLE_A)]; // Apply kick compensation
			} else {
				antiRecoilX = inv(polarValues[abs(varAntiRecoilEnd_H[currentWeapon[currentProfile]]) - get_rumble(RUMBLE_A)]); // Apply kick compensation
			}
		}
	}
	
	// See which type of anti-recoil is being used
	antiRecoilKickDurationX += get_rtime(); // Increase kick duration counter
	antiRecoilKickDurationY += get_rtime(); // Increase kick duration counter
	
	output(aimX, antiRecoilX);
	output(aimY, antiRecoilY * iif(varInverted, -1, 1));
	
	antiRecoilX = antiRecoilY = 0;
}

// Flushes the display buffer
function flushBuffer(x, y, size, color) {
	// Decrement value as it must begin at 1
	displayBuffer--; 
	
	// Check horizontal alignment
	switch(x) { 
		case alignRight {
			x = OLED_WIDTH - (displayBuffer * fontWidth[size]) - 4;
			break;	
		} case alignCenter {
			x = (OLED_WIDTH >> 1) - ((displayBuffer * fontWidth[size]) >> 1);
			break;
		}
	}
	
	// Check vertical alignment
	switch(y) { 
		case alignCenter {
			y = (OLED_HEIGHT >> 1) - (fontHeight[size] >> 1);
			break;
		} case alignBottom {
			y = OLED_HEIGHT - fontHeight[size] - 4;
			break;	
		}
	}
	
	puts_oled(x, y, size, displayBuffer, color); // Output display buffer
	displayBuffer = 1; // Reset display buffer
}

// Flushes the display buffer for a multiple item menu
function flushSelectedItemBuffer(item, line) {
	if(editMenuSelectedRow == item) {
		flushBuffer(alignLeft, line, OLED_FONT_SMALL, OLED_BLACK);
	} else {
		flushBuffer(alignLeft, line, OLED_FONT_SMALL, OLED_WHITE);
	}
}

// Format and generate output for uptime
function generateUptime(value, character) {
	insertNumber(value);
	insertCharacter(character);
}
 
// Checks if a weapon has all recoil values other than start value
function hasValues(index) {
	return iif(index != m16a4 && index != mutant && index < slr || index == vss, TRUE, FALSE);
}

// Alternative for the ternary operator
function iif(expression, truepart, falsepart) {
	// Evaluate if expression is true
	if(expression) {
		return truepart; // Return truepart
	}
	
	// Return falsepart
	return falsepart;
}

// Inserts a character into the display buffer
function insertCharacter(int value) {
	putc_oled(displayBuffer, value);
	displayBuffer++;
}

// Inserts a number into the display buffer
function insertNumber(int value) {
	
	if(value < 0) { // Check if value is negative
		insertCharacter(ASCII_MINUS); // Insert '-' into the display buffer
		value = abs(value); // Convert value to positive
	}
	
	displayBufferInsertCopyValue = value; // Create a copy of value to perform work on
	displayBufferInsertNumberOfDigits = 0; // Reset number of digits to 0
	
    // Determine the number of digits in the number by
    // dividing it by 10 repeatedly until it becomes 0
    // while not ignoring a value of 0
    do {
        displayBufferInsertCopyValue /= 10;
        displayBufferInsertNumberOfDigits++;
    } while(displayBufferInsertCopyValue)
    
    // Extract each digit of the number and store it in an array
    for(i = 0; i < displayBufferInsertNumberOfDigits; i++) {
        displayBufferInsertDigits[i] = (value % 10) + 48;
        value /= 10;
    }
    
    // Insert the digits in the order that they appear in the number
    for(i = displayBufferInsertNumberOfDigits - 1; i >= 0; i--) {
        insertCharacter(displayBufferInsertDigits[i]);
    }
}

// Inserts a string into the display buffer
function insertString(s) {
	// Loop through each character of the string
    do {
    	insertCharacter(duint8(s)); // Insert character into display buffer
    	s++; // Move to next character
    } while(duint8(s)) // Loop until no more characters
}

// Edit menu action not allowed
function menuActionFailed() {
	// Make sure it is not running, if so, terminate it
	if(combo_running(cboActionFailed)) { 
		combo_stop(cboActionFailed);
	}
	
	editMenuUpdate = !editMenuUpdate; // Disable edit menu display update
	combo_run(cboActionFailed); // Execute alert
}

// Menu action allowed
function menuActionSuccess() {
	// Make sure it is not running, if so, terminate it
	if(combo_running(cboActionSuccess)) { 
		combo_stop(cboActionSuccess);
	}
	
	combo_run(cboActionSuccess); // Execute alert
}

// Output value to stick and gradually reduce it as it approaches maximum movement
function output(stick, value) {
	if(value) {
		set_val(stick, clamp(value * (32767 - abs(get_val(stick))) / 32767 + get_val(stick), -32768, 32767));
	} else {
		set_val(stick, clamp(value * (-32768 + abs(get_val(stick))) / -32768 + get_val(stick), -32768, 32767));
	}
}

// Prints a number to the screen
function printNumber(x, y, number, size, color) {
	insertNumber(number);
	flushBuffer(x, y, size, color);
}

// Prints text to the screen
function printText(x, y, text, size, color) {
	insertString(text);
	flushBuffer(x, y, size, color);
}

// Print the uptime to the OLED display
function printUptime() {
	// Check days
	if(uptimeDays) { 
		generateUptime(uptimeDays, ASCII_LOWER_D);
	}
	// Check hours
	if(uptimeHours) { 
		generateUptime(uptimeHours, ASCII_LOWER_H);
	}
	// Check minutes
	if(uptimeMinutes) { 
		generateUptime(uptimeMinutes, ASCII_LOWER_M);
	}
	// Check seconds
	if(uptimeSeconds) { 
		generateUptime(uptimeSeconds, ASCII_LOWER_S);
	}
	
	// Print centered to OLED
	flushBuffer(alignCenter, alignCenter, OLED_FONT_SMALL, OLED_WHITE); 
}

// Removes any "movement" inside calibrated drift area and applies a deadzone
function removeDriftAndApplyDeadzone() {
	// If anti-drift is not enabled, we use 0 for low/high values.  Deadzone doesn't matter
	if(varAntidrift) {
		correctStickInput(varAntidriftLeft[antiDriftLeft], varAntidriftLeft[antiDriftRight], varDeadzone[deadzoneLeft], moveX);
		correctStickInput(varAntidriftLeft[antiDriftUp], varAntidriftLeft[antiDriftDown], varDeadzone[deadzoneLeft], moveY);
		correctStickInput(varAntidriftRight[antiDriftLeft], varAntidriftRight[antiDriftRight], varDeadzone[deadzoneRight], aimX);
		correctStickInput(varAntidriftRight[antiDriftUp], varAntidriftRight[antiDriftDown], varDeadzone[deadzoneRight], aimY);
	} else {
		// This is done because it's possible user has values saved
		// but for whatever reason wants anti-drift off
		// Deadzone doesn't matter, if user doesn't want to use script deadzone
		// they can leave it at 0
		correctStickInput(0, 0, varDeadzone[deadzoneLeft], moveX);
		correctStickInput(0, 0, varDeadzone[deadzoneLeft], moveY);
		correctStickInput(0, 0, varDeadzone[deadzoneRight], aimX);
		correctStickInput(0, 0, varDeadzone[deadzoneRight], aimY);
	}
}

// Sets button variables based on in-game settings
function setButtonLayout() {
	button[aim] = buttonLayoutMap[varControllerButtonLayout][aim];
	button[ads] = buttonLayoutMap[varControllerButtonLayout][ads];
	button[melee] = buttonLayoutMap[varControllerButtonLayout][melee];
	button[fire] = buttonLayoutMap[varControllerButtonLayout][fire];
	button[weapon] = buttonLayoutMap[varControllerButtonLayout][weapon];
	button[interact] = buttonLayoutMap[varControllerButtonLayout][interact];
	button[action] = buttonLayoutMap[varControllerButtonLayout][action];
	button[jump] = buttonLayoutMap[varControllerButtonLayout][jump];
	button[leanL] = buttonLayoutMap[varControllerButtonLayout][leanL];
	button[leanR] = buttonLayoutMap[varControllerButtonLayout][leanR];
	button[focus] = buttonLayoutMap[varControllerButtonLayout][focus];
	button[zoom] = buttonLayoutMap[varControllerButtonLayout][zoom];
}

// Attempts to bind button_to_set to a toggle combination
function setToggleButton(button_to_use, button_to_set, button_to_compare) {
	
	// Holding 'View' button will undo a previously set toggle combination button
	if(button_to_set == XB1_VIEW) {
		// Check if a buttin is set
		if(button_to_use) {
			button_to_use = 0; // Reset value
			editMenuUpdate = !editMenuUpdate; // Enable edit menu update
		}
	} else if(button_to_set != button_to_use) { // Check if value to set is different than current stored value for toggle
		if(button_to_set == button_to_compare) { // Make sure toggle combination [hold] button #1 does not equal [press] button #2
			combo_run(cboActionFailed); // Cannot map same buttons
		} else {
			button_to_use = button_to_set; // Set toggle button
		}
	}
	
	return button_to_use;
}

// Set controller configuration
function setControllerConfig() {
	setButtonLayout();
	setStickLayout();
}

// Sets the LED to the color provided as the parameter
function setLedColor(color) {
	set_hsb(colorValues[color][hue], colorValues[color][saturation], colorValues[color][brightness]);
}

// Sets the LED to a color based on the profile being used
function setProfileLedColor(profile) {
	if(!checkCombos()) { // Do not overlap with running combos that use the LEDs
		set_hsb(colorValues[varProfileColor[profile]][hue], colorValues[varProfileColor[profile]][saturation], colorValues[varProfileColor[profile]][brightness]);
	}
}

// Sets joystick-related variables
function setStickLayout() {
	// Set movement and aiming sticks
	aimX = POLAR_RX;
	aimY = POLAR_RY;
	moveX = POLAR_LX;
	moveY = POLAR_LY;
}

// Switches profiles
function switchProfile(profile) {
	
	// Check if last profile switch is still executing
	if(combo_running(cboSwitchProfile)) { // Check if last profile switch is still executing
		combo_stop(cboSwitchProfile); // Cancel it
	}
	
	// Check if an active toggle alert (i.e. Rapid Fire) is enabled
	if(combo_running(cboToggleAlert)) {
		combo_stop(cboToggleAlert);
	}
	
	// If screen saver is enabled, disable it
	if(screenSaverEnabled) {
		screenSaverEnabled = !screenSaverEnabled; // Disable screen saver
		screenSaverCounter = 0; // Reset counter
	}
	
	currentProfile = profile; // Set new profile
	combo_run(cboSwitchProfile); // Display notification
}

// Verifies that a toggle combination is not already set
function verifyToggleCombo(verify_button, index) {
	
	// Loop through each set of toggle buttons
	for(j = 0; j < sizeof(varToggleButton) / sizeof(varToggleButton[0]); j += 2) {
		if(varToggleButton[j] && varToggleButton[j + 1]) { // Make sure the buttons are accepted (0 = rejected from prior function)
			if(j != index) { // Do not compare against self, is already done in prior function
				if(varToggleButton[j] == varToggleButton[index] && varToggleButton[j + 1] == varToggleButton[index + 1]) {
					combo_run(cboActionFailed);
					return 0;
				}
			}
		}
	}
	
	editMenuUpdate = !editMenuUpdate; // Enable edit menu update
	combo_run(cboActionSuccess); // Notify user of success setting toggle button
	return verify_button; // Return button
}


/**************************************************************/
// User-defined settings
/**************************************************************/
// Load user-defined configuration settings
function loadSettings() {

	reset_spvar();
	
	// Read and check the first bit, if it is set, we know something should have been saved, otherwise we fall back on our default setting
	if(read_spvar(0, 1, 0)) {
		varAntidrift							= read_spvar(0, 1, 0);
		varAntidriftLeft[antiDriftUp]			= read_spvar(-4095, 4095, 0);
		varAntidriftLeft[antiDriftDown]			= read_spvar(-4095, 4095, 0);
		varAntidriftLeft[antiDriftLeft]			= read_spvar(-4095, 4095, 0);
		varAntidriftLeft[antiDriftRight]		= read_spvar(-4095, 4095, 0);
		varAntidriftRight[antiDriftUp]			= read_spvar(-4095, 4095, 0);
		varAntidriftRight[antiDriftDown]		= read_spvar(-4095, 4095, 0);
		varAntidriftRight[antiDriftLeft]		= read_spvar(-4095, 4095, 0);
		varAntidriftRight[antiDriftRight]		= read_spvar(-4095, 4095, 0);
		varControllerButtonLayout				= read_spvar(cblTypeA, cblTypeC, cblTypeB);
		varToggleButton[toggleProfile]			= read_spvar(0, XB1_X, 0); // RB is lowest value and X is highest value
		varToggleButton[toggleProfile + 1]		= read_spvar(0, XB1_X, 0); // RB is lowest value and X is highest value
		varToggleButton[toggleRapidFire]		= read_spvar(0, XB1_X, 0); // RB is lowest value and X is highest value
		varToggleButton[toggleRapidFire + 1]	= read_spvar(0, XB1_X, 0); // RB is lowest value and X is highest value
		varProfileColor[0]						= read_spvar(red, pink, blue);
		varProfileColor[1]						= read_spvar(red, pink, purple);
		varAutoFocus							= read_spvar(0, 1, 0);
		varBlockRumble							= read_spvar(0, 1, 0);
		varDeadzone[deadzoneLeft]				= read_spvar(0, 30, 0);
		varDeadzone[deadzoneRight]				= read_spvar(0, 30, 0);
		varInverted								= read_spvar(0, 1, 0);
		
		for(i = 0; i < 30; i++) {
			// Vertical recoil
			varAntiRecoilStart[i] = read_spvar(0, 100, 0);
			// Single fire guns do not need mid/end/etc.
			if(hasValues(i)) {
				// Vertical recoil cont'd
				varAntiRecoilMid[i] = read_spvar(0, 100, 0);
				varAntiRecoilEnd[i] = read_spvar(0, 100, 0);
				// Vertical times
				varAntiRecoilStartTime[i] = read_spvar(0, 100, 0);
				varAntiRecoilMidTime[i] = read_spvar(0, 100, 0);
				
				// Horizontal recoil
				varAntiRecoilStart_H[i] = read_spvar(-100, 100, 0);
				varAntiRecoilMid_H[i] = read_spvar(-100, 100, 0);
				varAntiRecoilEnd_H[i] = read_spvar(-100, 100, 0);
				// Horizontal times
				varAntiRecoilStartTime_H[i] = read_spvar(0, 63, 0);
				varAntiRecoilMidTime_H[i] = read_spvar(0, 63, 0);
			} else if(i < sniper && i != mk14) { // Mk14 has full auto option
				varRapidFireRecoil[i] = read_spvar(0, 100, 0);
			}
		}
		
		varRapidFireSpeed = read_spvar(1, 60, 10);
	} else {
		if(!DEBUG) {
			// Anti-drift
			varAntidrift							= 0;
			varAntidriftLeft[antiDriftUp]			= 0;
			varAntidriftLeft[antiDriftDown]			= 0;
			varAntidriftLeft[antiDriftLeft]			= 0;
			varAntidriftLeft[antiDriftRight]		= 0;
			varAntidriftRight[antiDriftUp]			= 0;
			varAntidriftRight[antiDriftDown]		= 0;
			varAntidriftRight[antiDriftLeft]		= 0;
			varAntidriftRight[antiDriftRight]		= 0;
			// Controller
			varControllerButtonLayout				= cblTypeB;
			// Toggles
			varToggleButton[toggleProfile]			= 0;
			varToggleButton[toggleProfile + 1]		= 0;
			varToggleButton[toggleRapidFire]		= 0;
			varToggleButton[toggleRapidFire + 1]	= 0;
			// Profiles
			varProfileColor[0]						= blue;
			varProfileColor[1]						= purple;
			// Settings
			varAutoFocus							= 0;
			varBlockRumble							= 0;
			varDeadzone[deadzoneLeft]				= 0;
			varDeadzone[deadzoneRight]				= 0;
			varInverted								= 0;
			// Initialize recoil values if there are none
			for(i = 0; i < 30; i++) {
				// Vertical recoil
				varAntiRecoilStart[i] = 0;
				// Single fire guns do not need mid/end/etc.
				if(hasValues(i)) {
					// Vertical recoil cont'd
					varAntiRecoilMid[i] = 0;
					varAntiRecoilEnd[i] = 0;
					// Vertical times
					varAntiRecoilStartTime[i] = 0;
					varAntiRecoilMidTime[i] = 0;
					// Horizontal recoil
					varAntiRecoilStart_H[i] = 0;
					varAntiRecoilMid_H[i] = 0;
					varAntiRecoilEnd_H[i] = 0;
					// Horizontal times
					varAntiRecoilStartTime_H[i] = 0;
					varAntiRecoilMidTime_H[i] = 0;
				} else if(i < sniper && i != mk14) {  // Mk14 has full auto option
					varRapidFireRecoil[i] = 0;
				}
			}
			varRapidFireSpeed = 10;
		} else {
			// Anti-drift
			varAntidrift							= 1;
			varAntidriftLeft[antiDriftUp]			= -2666;
			varAntidriftLeft[antiDriftDown]			= 763;
			varAntidriftLeft[antiDriftLeft]			= 683;
			varAntidriftLeft[antiDriftRight]		= 3160;
			varAntidriftRight[antiDriftUp]			= -4078;
			varAntidriftRight[antiDriftDown]		= -2735;
			varAntidriftRight[antiDriftLeft]		= 2528;
			varAntidriftRight[antiDriftRight]		= 4523;
			// Controller
			varControllerButtonLayout				= cblTypeB;
			// Toggles
			varToggleButton[toggleProfile]			= XB1_LT;
			varToggleButton[toggleProfile + 1]		= XB1_Y;
			varToggleButton[toggleRapidFire]		= XB1_LT;
			varToggleButton[toggleRapidFire + 1]	= XB1_LEFT;
			// Profiles
			varProfileColor[0]						= blue;
			varProfileColor[1]						= purple;
			// Settings
			varAutoFocus							= 1;
			varBlockRumble							= 1;
			varDeadzone[deadzoneLeft]				= 5;
			varDeadzone[deadzoneRight]				= 5;
			varInverted								= 1;
			varRapidFireSpeed = 10;
		}
	}
	
	setControllerConfig(); // Set controller configuration
}

// Save user-defined configuration settings
function saveSettings() {
	// Always reset the spvar state before saving to ensure that we are saving at the same location as we will later read
	reset_spvar();
	
	// Save a constant 1 to denote previously saved data, this range uses 1 bit
	save_spvar(1, 0, 1);
	save_spvar(varAntidrift, 0, 1);
	save_spvar(varAntidriftLeft[antiDriftUp], -4095, 4095);
	save_spvar(varAntidriftLeft[antiDriftDown], -4095, 4095);
	save_spvar(varAntidriftLeft[antiDriftLeft], -4095, 4095);
	save_spvar(varAntidriftLeft[antiDriftRight], -4095, 4095);
	save_spvar(varAntidriftRight[antiDriftUp], -4095, 4095);
	save_spvar(varAntidriftRight[antiDriftDown], -4095, 4095);
	save_spvar(varAntidriftRight[antiDriftLeft], -4095, 4095);
	save_spvar(varAntidriftRight[antiDriftRight], -4095, 4095);
	save_spvar(varControllerButtonLayout, cblTypeA, cblTypeC);
	save_spvar(varToggleButton[toggleProfile], 0, XB1_X); // RB is lowest value and X is highest value
	save_spvar(varToggleButton[toggleProfile + 1], 0, XB1_X); // RB is lowest value and X is highest value
	save_spvar(varToggleButton[toggleRapidFire], 0, XB1_X); // RB is lowest value and X is highest value
	save_spvar(varToggleButton[toggleRapidFire + 1], 0, XB1_X); // RB is lowest value and X is highest value
	save_spvar(varProfileColor[0], red, pink);
	save_spvar(varProfileColor[1], red, pink);
	save_spvar(varAutoFocus, 0, 1);
	save_spvar(varBlockRumble, 0, 1);
	save_spvar(varDeadzone[deadzoneLeft], 0, 30);
	save_spvar(varDeadzone[deadzoneRight], 0, 30);
	save_spvar(varInverted, 0, 1);

	for(i = 0; i < 30; i++) {
		// Vertical recoil
		save_spvar(varAntiRecoilStart[i], 0, 100);
		
		// Single fire guns do not need mid/end/etc.
		if(hasValues(i)) {
			// Vertical recoil cont'd
			save_spvar(varAntiRecoilMid[i], 0, 100);
			save_spvar(varAntiRecoilEnd[i], 0, 100);
			
			// Vertical times
			save_spvar(varAntiRecoilStartTime[i], 0, 100);
			save_spvar(varAntiRecoilMidTime[i], 0, 100);
			
			// Horizontal recoil
			save_spvar(varAntiRecoilStart_H[i], -100, 100);
			save_spvar(varAntiRecoilMid_H[i], -100, 100);
			save_spvar(varAntiRecoilEnd_H[i], -100, 100);
			
			// Horizontal times
			save_spvar(varAntiRecoilStartTime_H[i], 0, 63);
			save_spvar(varAntiRecoilMidTime_H[i], 0, 63);
		} else if(i < sniper && i != mk14) {  // Mk14 has full auto option
			save_spvar(varRapidFireRecoil[i], 0, 100);
		}
	}
	
	save_spvar(varRapidFireSpeed, 1, 60);
	setControllerConfig();
}

function reset_spvar() {
	 // Change this to say where it's safe to Roset storing data
	spvar_current_slot = SPVAR_1; 
	
	// Should always be 0, unless you're using part of the first SPVAR 
	// in which case you should also change the next line to include the 
	// value you are storing in the bits you are using
	spvar_current_bit = 0; 
	spvar_current_value = 0;
}

// Function used to count the number of bits used by the given value
function get_bit_count(val) {
	// We need to Roset at 0, we use spvar_tmp here as we need to track
	// the bits during our loop below
	spvar_tmp = 0; 
	
	// Loop while val is anything but 0
	while (val) { 
		// Increment the bit count by 1
		spvar_tmp++; 
		
		// Shift the value down 1 bit, once we have no more bits set this
		// will result in 0, unless the value is negative - in which case
		// this will be endless, we do abs here to make it always
		val = abs(val >> 1);
	}
	return spvar_tmp;
}

// Function used to count the number of bits used by 2 given values
function get_bit_count2(val1, val2) {
	// Get the highest bit count required for either min or max
	spvar_tmp = max(get_bit_count(val1), get_bit_count(val2));
	
	// Check if we need to know if the value is negative or not
	if (is_signed2(val1, val2)) {
		// If we need to track if the saved value is negative, we need 1 bit
		// for that specifically - the others are used to store the actual value
		spvar_tmp++;
	}
	return spvar_tmp;
}

// Function used to determine if either of 2 given values is negative
function is_signed2(val1, val2) {
	return (val1 < 0) || (val2 < 0);
}

// Function used to generate a bitmask for the sign bit, this will always be
// the highest bit in the range we're requesting it for, to do that - we need
// to Roset with the lowest bit set and move it up the number of steps there
// is between 1 and the bits we need, this needs to be a maximum of 31 but can
// never be negative
function make_sign(bits) { 
	return 1 << clamp(bits - 1, 0, 31);
}

// Function used to generate a full bitmask (essentially all bits set up to
// and including the number of bits given)
function make_full_mask(bits) {	
	// If we're wanting a bitmask for all bits, we can simply return -1
	// (which is all bits set to 1)
	if (bits == 32) { 
		return -1;
	}
	
	// What we do here is basically take a value with all bits except the highest
	// set and shift them down as many times as we need to get a mask that fits
	// the bit count we're looking for
	return 0x7FFFFFFF >> (31 - bits);
}

// Function used to generate a bitmask for just the bits required for the value
// part of a signed range, this means all the bits below the sign bit
function make_sign_mask(bits) {
	return make_full_mask(bits - 1);
}

// Function used to pack a value that has potential for being negative in a way
// that we use the least number of bits we really need to represent the value
function pack_i(val, bits) {

	// Check if we have a negative value, if so - handle it accordingly
	if (val < 0) { 
		// Get the positive version of the value and keep the bits that are within
		// range of what we're doing and add the sign bit since we have a negative
		// value and return the result
		return (abs(val) & make_sign_mask(bits)) | make_sign(bits);
	}
	
	// Get the bits that are within our range
	return val & make_sign_mask(bits); 
}

// Function used to unpack (restore) a value that has potential for being negative,
// essentially reversing what pack_i does above
function unpack_i(val, bits) {

	// Check if the stored value is supposed to be negative
	if (val & make_sign(bits)) {
		// Retrieve the stored positive value and subtract it from 0 (resulting in
		// the same value except negative), return the result
		return 0 - (val & make_sign_mask(bits));
	}
	
	// Retrieve the stored positive value and return it
	return val & make_sign_mask(bits);
}

// Function used to read the value of a SPVAR without any limits
function read_spvar_slot(slot) {
	return get_pvar(slot, 0x80000000, 0x7FFFFFFF, 0);
}

// Function used to save your value in the SPVARs, this is the function you'll be
// calling when saving a value. You need to provide the value to save aswell as
// the range (minimum and maximum value, this is how we determine how many bits
// to use when saving this value)
function save_spvar(val, min, max) {

	// Set spvar_bits to the number of bits we need for this range
	spvar_bits = get_bit_count2(min, max); 
	
	// Make sure the value is within our defined range to begin with
	val = clamp(val, min, max); 
	
	// If either min or max is negative, we need to pack this value as a
	// possibly negative value
	if (is_signed2(min, max)) { 
		// Pack as signed value (possibly negative)
		val = pack_i(val, spvar_bits);
	}
	
	// Pack as unsigned value (always positive), this essentially just makes the
	// resulting value not have any extra bits set - it's safe to use after the
	// signed packing since we're not using any bits outside of the unsigned range anyways
	val = val & make_full_mask(spvar_bits); 
	
	// Check if there is not enough bits remaining to save this value as-is. if
	// there aren't enough bits, we save what we can here and store the remaining
	// bits in the next spvar, if this means we're hitting the end, we can make
	// this smaller by handling the case where we use all bits here aswell
	if (spvar_bits >= 32 - spvar_current_bit) { 
		// Add what we can to the current value where there is bits available to use
		spvar_current_value = spvar_current_value | (val << spvar_current_bit); 
		// Save the current SPVAR before advancing to the next one
		set_pvar(spvar_current_slot, spvar_current_value); 
		// Move to the next slot
		spvar_current_slot++; 
		// Update the required bits according to our needs for the next slot, 
		// if we don't do this here, we'll screw up the saved value by moving
		// it too far out of range
		spvar_bits -= (32 - spvar_current_bit);
		// Move the remaining bits down, discarding the bits we've already saved
		val = val >> (32 - spvar_current_bit); 
		// Reset the current bit counter since we're Roseting with a new SPVAR
		spvar_current_bit = 0; 
		// Reset our value so we Roset clean, we aren't currently using any bits anyways
		spvar_current_value = 0; 
	}
	
	// Merge the current SPVAR value with our currently value where there is space to keep our value
	spvar_current_value = spvar_current_value | (val << spvar_current_bit); 
	// Move up the counter of next available bit to where we are currently saving data at
	spvar_current_bit += spvar_bits; 
	
	if (!spvar_current_bit) {
		// Reset our value so we Roset clean, we aren't currently using any bits anyways
		spvar_current_value = 0; 
	}
	
	// Save the SPVAR with the current value, this won't write anything to flash unless
	//the value changed - so we can do this for each variable saved to no risk missing anything
	set_pvar(spvar_current_slot, spvar_current_value); 
}

// Function used to read your value from the SPVARs, this is the function you'll be
// calling when reading a value. You need to provide the range (minimum and maximum
// value, this is how we determine how many bits to use when reading the value) aswell
// as a default value if what we read is out of range
function read_spvar(min, max, def) {

	// Set spvar_bits to the number of bits we need for this range
	spvar_bits = get_bit_count2(min, max); 
	
	// Read the current SPVAR value from flash and shift them into position,
	// we'll handle split values next
	spvar_current_value = (read_spvar_slot(spvar_current_slot) >> spvar_current_bit) & make_full_mask(spvar_bits);
	
	// Check if we are dealing with a split SPVAR value, essentially if the current
	// position means we're using more than 32 bits in the SPVAR, we need to retrieve
	// the missing bits from the next SPVAR and put them back to our current value,
	// we use the same space saving trick here as in the save function
	if (spvar_bits >= 32 - spvar_current_bit) {
		spvar_current_value = (spvar_current_value & make_full_mask(32 - spvar_current_bit)) | ((read_spvar_slot(spvar_current_slot + 1) & make_full_mask(spvar_bits - (32 - spvar_current_bit))) << (32 - spvar_current_bit));
		//Below is a breakdown of the line above, with each step done one at a time instead of all at once - this however increases codesize - the below code is to explain how it all works tho
		//spvar_tmp = read_spvar_slot(spvar_current_slot + 1); // Read the SPVAR slot coming after the initial one we used to spvar_tmp from flash, we need to maintain the data we've read thus far, but also add on what we have in flash for the next SPVAR
		//spvar_tmp = spvar_tmp & make_full_mask(spvar_bits - (32 - spvar_current_bit)); // Extract the bits we need need (the ones that didn't fit in the previous SPVAR)
		//spvar_tmp = spvar_tmp << (32 - spvar_current_bit); // Move the bits into their original position, they were stored at the beginning of the new SPVAR but belong at the top of the currently read value
		//spvar_current_value = (spvar_current_value & make_full_mask(32 - spvar_current_bit)) | spvar_tmp; // put all bits together again with the part read from the first SPVAR cleaned up to only include the bits from this variable/value and not all bits set in the upper range like they normally are
	}
	
	// Move up the counter of next available bit to where we are will be reading data from next
	spvar_current_bit += spvar_bits;
	// Extract all bits included for this value and discard any other bits
	spvar_current_value = spvar_current_value & make_full_mask(spvar_bits); 
	
	if (spvar_current_bit >= 32) {
		// Move to the next SPVAR slot
		spvar_current_slot++;
		// Remove 32 from the spvar_current_bit tracker since we've gone beyond what we can do here
		spvar_current_bit -= 32;
	}
	
	// Check if the value can be negative and handle it accordingly
	if (is_signed2(min, max)) { 
		// Restore the signed, possibly negative value
		spvar_current_value = unpack_i(spvar_current_value, spvar_bits); 
	}
	
	// Check if the value is below our specified min or above our specified max,
	// if so - return the default value instead
	if (spvar_current_value < min || spvar_current_value > max) { 
		// This can be changed to min instead as a reasonable default with the
		// default parameter being removed if you don't need to have a override
		// value for the default when out of range, that will save a bit of code size
		return def; 
	}
	
	// Return the retrieved value to the user since it's within the expected range
	return spvar_current_value;
}


/**************************************************************/
// Combos
/**************************************************************/
combo cboActionSuccess {
	set_hsb(colorValues[green][hue], colorValues[green][saturation], colorValues[green][brightness]);
	set_rumble(RUMBLE_B, 80);
	wait(250);
	reset_rumble();
}

combo cboActionFailed {
	set_hsb(colorValues[red][hue], colorValues[red][saturation], colorValues[red][brightness]);
	set_rumble(RUMBLE_A, 80);
	wait(250);
	reset_rumble();
}

combo cboAutoFocus {
	wait(250);
	set_val(button[focus], 100);
	wait(8000);
	set_val(button[focus], 0);
	wait(10000);
	set_val(button[focus], 100);
	wait(3000);
	set_val(button[focus], 0);
	wait(6000);
	set_val(button[focus], 100);
	wait(3200);
	set_val(button[focus], 0);
	wait(6200);
	set_val(button[focus], 100);
	wait(3200);
	set_val(button[focus], 0);
	wait(6000);
}

combo cboCalibrationComplete {
	cls_oled(OLED_BLACK);
	set_rumble(RUMBLE_B, 100);
	setLedColor(iif(antiDriftCalibrationCanSet == 2, yellow, iif(antiDriftCalibrationCanSet, green, red)));
	printText(alignCenter, alignCenter, antiDriftCalibrationResult[antiDriftCalibrationCanSet], OLED_FONT_SMALL, OLED_WHITE);
	wait(1440);
	reset_rumble();
	antiDriftCalibrationState = !antiDriftCalibrationState; // Disable calibration
	editMenuUpdate = !editMenuUpdate; // Update edit menu
	// Reset calibration variables
	antiDriftCalibrationCanSet = FALSE;
	antiDriftCalibrationInRange = FALSE;
}

combo cboScriptPaused {
	set_rgb(255, 30, 0);
	wait(150);
	set_rgb(0, 0, 0);
	wait(150);
}

combo cboRapidFire {
	// Low value (LCM of possible VM speeds) for immediate fire
	set_val(TRACE_6, 10);
	wait(120 / varRapidFireSpeed);
	set_val(button[fire], 0);
	wait(880 / varRapidFireSpeed);
	executeAntiRecoil();
}

combo cboSaveSettings {
	cls_oled(OLED_BLACK);
	printText(alignCenter, alignCenter, settingsSaved[0], OLED_FONT_SMALL, OLED_WHITE);
	set_hsb(colorValues[green][hue], colorValues[green][saturation], colorValues[green][brightness]);
	set_rumble(RUMBLE_B, 100);
	wait(500);
	reset_rumble();
	saveSettings();
	homeUpdate = !homeUpdate;
}

combo cboSwitchProfile {
	cls_oled(OLED_BLACK);
	insertString(weaponName[currentWeapon[currentProfile]]);
	flushBuffer(alignCenter, alignCenter, OLED_FONT_SMALL, OLED_WHITE);
	wait(1000);
	cls_oled(OLED_BLACK);
}

combo cboToggleAlert {
	setProfileLedColor(currentProfile);
	wait(250);
	set_hsb(0, 0, 0); // Off
	wait(250);
}

combo cboToggleOff {
	set_hsb(colorValues[yellow][hue], colorValues[yellow][saturation], colorValues[yellow][brightness]);
	set_rumble(RUMBLE_A, 75);
	wait(120);
	set_hsb(colorValues[red][hue], colorValues[red][saturation], colorValues[red][brightness]);
	wait(240);
	set_hsb(colorValues[yellow][hue], colorValues[yellow][saturation], colorValues[yellow][brightness]);
	set_rumble(RUMBLE_A, 75);
	wait(120);
	reset_rumble();
}

combo cboToggleOn {
	set_hsb(colorValues[yellow][hue], colorValues[yellow][saturation], colorValues[yellow][brightness]);
	set_rumble(RUMBLE_B, 75);
	wait(120);
	set_hsb(colorValues[green][hue], colorValues[green][saturation], colorValues[green][brightness]);
	wait(240);
	set_hsb(colorValues[yellow][hue], colorValues[yellow][saturation], colorValues[yellow][brightness]);
	set_rumble(RUMBLE_A, 75);
	wait(120);
	reset_rumble();
}


combo cboToggleRapidFire {
	if(rapidFire[currentProfile]) {
		combo_run(cboToggleOn);
	} else {
		combo_run(cboToggleOff);
	}
	cls_oled(OLED_BLACK);
	printText(alignCenter, alignCenter, toggleMessages[rapidFire[currentProfile]], OLED_FONT_SMALL, OLED_WHITE);
	wait(960);
	cls_oled(OLED_BLACK);
}


combo cboWeaponDisplay {
	printText(alignCenter, alignCenter, weaponName[currentWeapon[currentProfile]], OLED_FONT_SMALL, OLED_WHITE);
	wait(3500);
	cls_oled(OLED_BLACK);
}

/**************************************************************/
// Tables
/**************************************************************/
//
// Polar stick values (0 - 100)
const int16 polarValues[] = {
    0,
	328, 656, 984, 1312, 1640, 1968, 2296, 2624, 2952, 3280,
    3608, 3936, 4264, 4592, 4920, 5248, 5576, 5904, 6232, 6560,
    6888, 7216, 7544, 7872, 8200, 8528, 8856, 9184, 9512, 9840,
    10168, 10496, 10824, 11152, 11480, 11808, 12136, 12464, 12792, 13120,
    13448, 13776, 14104, 14432, 14760, 15088, 15416, 15744, 16072, 16400,
    16728, 17056, 17384, 17712, 18040, 18368, 18696, 19024, 19352, 19680,
    20008, 20336, 20664, 20992, 21320, 21648, 21976, 22304, 22632, 22960,
    23288, 23616, 23944, 24272, 24600, 24928, 25256, 25584, 25912, 26240,
    26568, 26896, 27224, 27552, 27880, 28208, 28536, 28864, 29192, 29520,
    29848, 30176, 30504, 30832, 31160, 31488, 31816, 32144, 32472, 32767

} 